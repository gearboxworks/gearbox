
/******************************************************************************
*
*   FILE
*   ----
*   HMIHelperLCEData.c
*
*   History
*   -------
*   2017-03-30   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_subModelLifeCycleEntry
#define OV_COMPILE_LIBRARY_subModelLifeCycleEntry
#endif


#include "libov/ov_macros.h"
#include "subModelLifeCycleEntry.h"

OV_DLLFNCEXPORT void subModelLifeCycleEntry_HMIHelperLCEData_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*    
    *   local variables
    */
	OV_RESULT result = 0;
    OV_INSTPTR_subModelLifeCycleEntry_HMIHelperLCEData pinst = Ov_StaticPtrCast(subModelLifeCycleEntry_HMIHelperLCEData, pfb);
    OV_INSTPTR_ov_object pobj = NULL;
	OV_INSTPTR_lifeCycleEntry_LifeCycleEntry pchild = NULL;
	OV_INSTPTR_lifeCycleEntry_LifeCycleArchive pArchive = NULL;
	OV_INSTPTR_subModelLifeCycleEntry_SubModelLifeCycleEntry pSubModel = NULL;
	OV_INSTPTR_openaas_aas paas = NULL;

	pinst->v_OutputType = 0;
	Ov_SetDynamicVectorLength(&pinst->v_xValueStatic, 0, TIME);
	Ov_SetDynamicVectorLength(&pinst->v_yValueStatic, 0, DOUBLE);
	ov_string_setvalue(&pinst->v_yUnitStatic, "");
	pinst->v_yValueDynamic = 0;
	ov_string_setvalue(&pinst->v_yUnitDynamic, "");
	pinst->v_Error = FALSE;
	ov_string_setvalue(&pinst->v_ErrorText, "");
	pinst->v_ErrorDynamic = FALSE;
	ov_string_setvalue(&pinst->v_ErrorTextDynamic, "");
	pinst->v_ErrorStatic = FALSE;
	ov_string_setvalue(&pinst->v_ErrorTextStatic, "");

	OV_UINT len = 0;
	OV_STRING *pathList = NULL;
	OV_STRING path = NULL;
	pathList = ov_string_split(pinst->v_AASPath, "/", &len);

	for (OV_UINT i = 4; i < len; i++){
		if (i == 4)
			ov_string_setvalue(&path, "/");
		else
			ov_string_append(&path, "/");
		ov_string_append(&path, pathList[i]);
	}
	ov_string_freelist(pathList);

	pobj = ov_path_getobjectpointer(path,2);
	ov_database_free(path);
	if (!pobj){
		pinst->v_Error = TRUE;
		ov_string_setvalue(&pinst->v_ErrorText, "Could not find an object for this path");
		return;
	}

	paas = Ov_DynamicPtrCast(openaas_aas, pobj);
	if (!paas){
		pinst->v_Error = TRUE;
		ov_string_setvalue(&pinst->v_ErrorText, "Object is not of aas-Type");
		return;
	}

	// for static
	OV_UINT i = 0;
	OV_TIME time;
	result = ov_time_asciitotime_local(&time, pinst->v_TimeStamp);
	if (result){
		pinst->v_Error = TRUE;
		ov_string_setvalue(&pinst->v_ErrorText, "Converting TimeStamp failed");
		return;
	}

	// Search for Start and Stop LCE
	OV_UINT lceCount = 0;
	// printing x- and y-values
	OV_TIME xValue;
	OV_STRING tmpString = NULL;
	// Search for LCE Archiv
	Ov_ForEachChildEx(ov_containment, &paas->p_Body, pSubModel, subModelLifeCycleEntry_SubModelLifeCycleEntry){
		pArchive = Ov_DynamicPtrCast(lifeCycleEntry_LifeCycleArchive, &pSubModel->p_LifeCycleArchiv);
	}

	if (!pArchive){
		pinst->v_Error = TRUE;
		ov_string_setvalue(&pinst->v_ErrorText, "Could not find the LCE Archive in the AAS");
		return;
	}


	Ov_ForEachChildEx(ov_containment, pArchive, pchild, lifeCycleEntry_LifeCycleEntry){
		if (ov_string_compare(pchild->v_EventClass, pinst->v_EventClass) == OV_STRCMP_EQUAL && ov_string_compare(pchild->v_Subject, pinst->v_Subject) == OV_STRCMP_EQUAL){
			// find fitting LCE
			switch(ov_time_compare(&pchild->v_TimeStamp, &time)){
				case OV_TIMECMP_AFTER:
				break;
				case OV_TIMECMP_EQUAL:
					lceCount = 1;
					if(!(pchild->v_Data.value.vartype & OV_VT_ISVECTOR)){
						if (pinst->v_ErrorStatic == FALSE){
							pinst->v_ErrorStatic = TRUE;
							ov_string_setvalue(&pinst->v_ErrorTextStatic, "Only Arrays in Data supported");
						}
					}else{
						switch (pchild->v_Data.value.vartype & OV_VT_KSMASK) {
							case OV_VT_UINT_VEC:
								xValue = pchild->v_TimeStamp;
								for (OV_UINT arrayCount = 0; arrayCount < pchild->v_Data.value.valueunion.val_uint_vec.veclen; arrayCount++){
									pinst->v_OutputType = 1;
									if (arrayCount > 0){
										ov_time_add(&xValue, &xValue, &pinst->v_TimeSpanBetweenValues);
										Ov_SetDynamicVectorLength(&pinst->v_xValueStatic, pinst->v_xValueStatic.veclen + 1, TIME);
										pinst->v_xValueStatic.value[pinst->v_xValueStatic.veclen-1] = xValue;
										Ov_SetDynamicVectorLength(&pinst->v_yValueStatic, pinst->v_yValueStatic.veclen + 1, DOUBLE);
										pinst->v_yValueStatic.value[pinst->v_yValueStatic.veclen-1] = pchild->v_Data.value.valueunion.val_uint_vec.value[arrayCount];
									}else{
										Ov_SetDynamicVectorLength(&pinst->v_xValueStatic, pinst->v_xValueStatic.veclen + 1, TIME);
										pinst->v_xValueStatic.value[pinst->v_xValueStatic.veclen-1] = xValue;
										Ov_SetDynamicVectorLength(&pinst->v_yValueStatic, pinst->v_yValueStatic.veclen + 1, DOUBLE);
										pinst->v_yValueStatic.value[pinst->v_yValueStatic.veclen-1] = pchild->v_Data.value.valueunion.val_uint_vec.value[arrayCount];
									}
								}
							break;
							case OV_VT_INT_VEC:
								xValue = pchild->v_TimeStamp;
								for (OV_UINT arrayCount = 0; arrayCount < pchild->v_Data.value.valueunion.val_int_vec.veclen; arrayCount++){
									pinst->v_OutputType = 1;
									if (arrayCount > 0){
										ov_time_add(&xValue, &xValue, &pinst->v_TimeSpanBetweenValues);
										Ov_SetDynamicVectorLength(&pinst->v_xValueStatic, pinst->v_xValueStatic.veclen + 1, TIME);
										pinst->v_xValueStatic.value[pinst->v_xValueStatic.veclen-1] = xValue;
										Ov_SetDynamicVectorLength(&pinst->v_yValueStatic, pinst->v_yValueStatic.veclen + 1, DOUBLE);
										pinst->v_yValueStatic.value[pinst->v_yValueStatic.veclen-1] = pchild->v_Data.value.valueunion.val_int_vec.value[arrayCount];
									}else{
										Ov_SetDynamicVectorLength(&pinst->v_xValueStatic, pinst->v_xValueStatic.veclen + 1, TIME);
										pinst->v_xValueStatic.value[pinst->v_xValueStatic.veclen-1] = xValue;
										Ov_SetDynamicVectorLength(&pinst->v_yValueStatic, pinst->v_yValueStatic.veclen + 1, DOUBLE);
										pinst->v_yValueStatic.value[pinst->v_yValueStatic.veclen-1] = pchild->v_Data.value.valueunion.val_int_vec.value[arrayCount];
									}
								}
							break;
							case OV_VT_SINGLE_VEC:
								xValue = pchild->v_TimeStamp;
								for (OV_UINT arrayCount = 0; arrayCount < pchild->v_Data.value.valueunion.val_single_vec.veclen; arrayCount++){
									pinst->v_OutputType = 1;
									if (arrayCount > 0){
										ov_time_add(&xValue, &xValue, &pinst->v_TimeSpanBetweenValues);
										Ov_SetDynamicVectorLength(&pinst->v_xValueStatic, pinst->v_xValueStatic.veclen + 1, TIME);
										pinst->v_xValueStatic.value[pinst->v_xValueStatic.veclen-1] = xValue;
										Ov_SetDynamicVectorLength(&pinst->v_yValueStatic, pinst->v_yValueStatic.veclen + 1, DOUBLE);
										pinst->v_yValueStatic.value[pinst->v_yValueStatic.veclen-1] = pchild->v_Data.value.valueunion.val_single_vec.value[arrayCount];
									}else{
										Ov_SetDynamicVectorLength(&pinst->v_xValueStatic, pinst->v_xValueStatic.veclen + 1, TIME);
										pinst->v_xValueStatic.value[pinst->v_xValueStatic.veclen-1] = xValue;
										Ov_SetDynamicVectorLength(&pinst->v_yValueStatic, pinst->v_yValueStatic.veclen + 1, DOUBLE);
										pinst->v_yValueStatic.value[pinst->v_yValueStatic.veclen-1] = pchild->v_Data.value.valueunion.val_single_vec.value[arrayCount];
									}
								}
							break;
							case OV_VT_DOUBLE_VEC:
								xValue = pchild->v_TimeStamp;
								for (OV_UINT arrayCount = 0; arrayCount < pchild->v_Data.value.valueunion.val_double_vec.veclen; arrayCount++){
									pinst->v_OutputType = 1;
									if (arrayCount > 0){
										ov_time_add(&xValue, &xValue, &pinst->v_TimeSpanBetweenValues);
										Ov_SetDynamicVectorLength(&pinst->v_xValueStatic, pinst->v_xValueStatic.veclen + 1, TIME);
										pinst->v_xValueStatic.value[pinst->v_xValueStatic.veclen-1] = xValue;
										Ov_SetDynamicVectorLength(&pinst->v_yValueStatic, pinst->v_yValueStatic.veclen + 1, DOUBLE);
										pinst->v_yValueStatic.value[pinst->v_yValueStatic.veclen-1] = pchild->v_Data.value.valueunion.val_double_vec.value[arrayCount];
									}else{
										Ov_SetDynamicVectorLength(&pinst->v_xValueStatic, pinst->v_xValueStatic.veclen + 1, TIME);
										pinst->v_xValueStatic.value[pinst->v_xValueStatic.veclen-1] = xValue;
										Ov_SetDynamicVectorLength(&pinst->v_yValueStatic, pinst->v_yValueStatic.veclen + 1, DOUBLE);
										pinst->v_yValueStatic.value[pinst->v_yValueStatic.veclen-1] = pchild->v_Data.value.valueunion.val_double_vec.value[arrayCount];
									}
								}
							break;
							default:
								if (pinst->v_ErrorStatic == FALSE){
									pinst->v_ErrorStatic = TRUE;
									ov_string_print(&pinst->v_ErrorTextStatic, "DataType of LCE:%s not supported", pchild->v_identifier);
								}
							break;
						}
					}
				break;
				case OV_TIMECMP_BEFORE:
				break;
			}
		}
	}

	if (lceCount == 0){
		pinst->v_Error = TRUE;
		ov_string_setvalue(&pinst->v_ErrorText, "Could not find an fitting object in LifeCycleArchive");
		return;
	}

	// for dynamic
	pobj = NULL;
	pchild = NULL;
	i = 0;
	do{
		if (i == 0){
			i++;
			pobj = Ov_GetLastChild(ov_containment, pArchive);
			pchild = Ov_DynamicPtrCast(lifeCycleEntry_LifeCycleEntry, pobj);
			if (!pchild){
				continue;
			}
		}

		pobj = Ov_GetPreviousChild(ov_containment, pchild);
		if (!pobj){
			if (pinst->v_ErrorDynamic == FALSE){
				pinst->v_ErrorDynamic = TRUE;
				ov_string_setvalue(&pinst->v_ErrorTextDynamic, "Could not find an object for dynamic values");
			}
			break;
		}
		pchild = Ov_DynamicPtrCast(lifeCycleEntry_LifeCycleEntry, pobj);
		if (!pchild){
			continue;
		}
	}while(ov_string_compare(pchild->v_EventClass, pinst->v_EventClass) != OV_STRCMP_EQUAL || ov_string_compare(pchild->v_Subject, pinst->v_Subject) != OV_STRCMP_EQUAL);

	if (pinst->v_ErrorDynamic == FALSE){
		if(!(pchild->v_Data.value.vartype & OV_VT_ISVECTOR)){
			switch(pchild->v_Data.value.vartype & OV_VT_KSMASK){
				case OV_VT_DOUBLE:
					pinst->v_xValueDynamic = pchild->v_TimeStamp;
					pinst->v_yValueDynamic = pchild->v_Data.value.valueunion.val_double;
					pinst->v_OutputType = 2;
				break;
				case OV_VT_INT:
					pinst->v_xValueDynamic = pchild->v_TimeStamp;
					pinst->v_yValueDynamic = pchild->v_Data.value.valueunion.val_int;
					pinst->v_OutputType = 2;
				break;
				case OV_VT_UINT:
					pinst->v_xValueDynamic = pchild->v_TimeStamp;
					pinst->v_yValueDynamic = pchild->v_Data.value.valueunion.val_uint;
					pinst->v_OutputType = 2;
				break;
				case OV_VT_SINGLE:
					pinst->v_xValueDynamic = pchild->v_TimeStamp;
					pinst->v_yValueDynamic = pchild->v_Data.value.valueunion.val_single;
					pinst->v_OutputType = 2;
				break;
				case OV_VT_BOOL:
				case OV_VT_STRING:
				default:
					if (pinst->v_ErrorDynamic == FALSE){
						pinst->v_ErrorDynamic = TRUE;
						ov_string_setvalue(&pinst->v_ErrorTextDynamic, "DataType not supported");
						pinst->v_yValueDynamic = 0;
						pinst->v_xValueDynamic.secs = 0;
						pinst->v_xValueDynamic.usecs = 0;
					}
				break;
			}
		}else{
			if (pinst->v_ErrorDynamic == FALSE){
				pinst->v_ErrorDynamic = TRUE;
				ov_string_setvalue(&pinst->v_ErrorTextDynamic, "Arrays are not supported");
				pinst->v_yValueDynamic = 0;
				pinst->v_xValueDynamic.secs = 0;
				pinst->v_xValueDynamic.usecs = 0;
			}
		}
	}



	ov_database_free(tmpString);

	return;
}

