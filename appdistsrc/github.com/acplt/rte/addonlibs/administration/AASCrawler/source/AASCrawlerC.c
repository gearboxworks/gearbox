
/******************************************************************************
*
*   FILE
*   ----
*   AASCrawlerC.c
*
*   History
*   -------
*   2018-09-19   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_AASCrawler
#define OV_COMPILE_LIBRARY_AASCrawler
#endif


#include "AASCrawler.h"
#include "libov/ov_macros.h"
#include "libov/ov_path.h"

struct statement{
	OV_STRING carrierID;
	OV_STRING propertyID;
	OV_STRING expressionSemantic;
	OV_STRING relation;
	OV_STRING value;
	OV_STRING valueType;
	OV_STRING subModel;
};

void AASCrawler_AASHttpClient_Callback(OV_INSTPTR_ov_domain instanceCalled, OV_INSTPTR_ov_domain instanceCalling){
	OV_INSTPTR_AASCrawler_AASHttpClient	thisCl = Ov_DynamicPtrCast(AASCrawler_AASHttpClient, instanceCalling);
	OV_RESULT resultOV = OV_ERR_OK;
	if(ov_string_match(thisCl->v_contentType, "application/json*") == FALSE){
		ov_logfile_info("Error wrong contentType");
		thisCl->v_isInUse = FALSE;
		return;
	}

	json_data jsonData;
	json_data_init(&jsonData);
	jsonData.js = thisCl->v_messageBody;

	if(jsonTokenize(&jsonData) != OV_ERR_OK) {
		ov_logfile_info("Error while parsing json");
		thisCl->v_isInUse = FALSE;
		return;
	}

	OV_UINT statementsArraySize = 0;
	struct statement *statements = NULL;
	OV_STRING_VEC jsonTags;
	jsonTags.value = NULL;
	jsonTags.veclen = 0;
	Ov_SetDynamicVectorLength(&jsonTags, 1, STRING);
	ov_string_setvalue(&jsonTags.value[0], "statements");
	OV_UINT_VEC tokenIndex;
	tokenIndex.value = NULL;
	tokenIndex.veclen = 0;
	Ov_SetDynamicVectorLength(&tokenIndex, 1, UINT);

	jsonGetTokenIndexByTags(jsonTags, jsonData, 0, &tokenIndex);


	// get statements from JSON
	statementsArraySize = jsonData.token[tokenIndex.value[0]+1].size;
	statements = malloc(sizeof(struct statement)*statementsArraySize);
	for (OV_UINT i = 0; i < statementsArraySize; i++){
		// value + 2 start of objects + i*15 next object + 2 values of carrierID
		statements[i].carrierID = NULL;
		jsonGetValueByToken(jsonData.js, &jsonData.token[tokenIndex.value[0]+2+i*15+2], &statements[i].carrierID);
		// value + 2 start of objects + i*15 next object + 4 values of propertyID
		statements[i].propertyID = NULL;
		jsonGetValueByToken(jsonData.js, &jsonData.token[tokenIndex.value[0]+2+i*15+4], &statements[i].propertyID);
		// value + 2 start of objects + i*15 next object + 6 values of expressionSemantic
		statements[i].expressionSemantic = NULL;
		jsonGetValueByToken(jsonData.js, &jsonData.token[tokenIndex.value[0]+2+i*15+6], &statements[i].expressionSemantic);
		// value + 2 start of objects + i*15 next object + 8 values of relation
		statements[i].relation = NULL;
		jsonGetValueByToken(jsonData.js, &jsonData.token[tokenIndex.value[0]+2+i*15+8], &statements[i].relation);
		// value + 2 start of objects + i*15 next object + 10 values of value
		statements[i].value = NULL;
		jsonGetValueByToken(jsonData.js, &jsonData.token[tokenIndex.value[0]+2+i*15+10], &statements[i].value);
		// value + 2 start of objects + i*15 next object + 10 values of value
		statements[i].valueType = NULL;
		jsonGetValueByToken(jsonData.js, &jsonData.token[tokenIndex.value[0]+2+i*15+12], &statements[i].valueType);
		// value + 2 start of objects + i*15 next object + 12 values of subModel
		statements[i].subModel = NULL;
		jsonGetValueByToken(jsonData.js, &jsonData.token[tokenIndex.value[0]+2+i*15+14], &statements[i].subModel);
	}
	// delete old registered Data
	// TODO: Extend to multiDBWrapper
	OV_INSTPTR_openAASDiscoveryServer_AASCrawler pCrawler = NULL;
	OV_INSTPTR_openAASDiscoveryServer_DBWrapper pDBWrapper = NULL;
	OV_VTBLPTR_openAASDiscoveryServer_DBWrapper pDBWrapperVTable = NULL;
	pCrawler = Ov_DynamicPtrCast(openAASDiscoveryServer_AASCrawler, Ov_GetParent(ov_containment, thisCl));
	if (!pCrawler){
		goto FINALIZE;
	}
	pDBWrapper = Ov_DynamicPtrCast(openAASDiscoveryServer_DBWrapper, ov_path_getobjectpointer(pCrawler->v_DBWrapperPath, 2));
	if (!pDBWrapper){
		ov_logfile_error("Could not find DBWrapper Object");
		goto FINALIZE;
	}
	Ov_GetVTablePtr(openAASDiscoveryServer_DBWrapper,pDBWrapperVTable, pDBWrapper);
	OV_STRING table  = NULL;
	OV_STRING tmpField = "ComponentID";
	OV_STRING tmpValue = NULL;
	ov_string_print(&tmpValue, "%s", thisCl->v_ComponentID);
	table  = "statements_TextBoolean";
	resultOV = pDBWrapperVTable->m_deleteData(pDBWrapper, table, &tmpField, 1, &tmpValue, 1);
	table  = "statements_Numeric";
	resultOV = pDBWrapperVTable->m_deleteData(pDBWrapper, table, &tmpField, 1, &tmpValue, 1);
	table  = "PropertyID";
	resultOV = pDBWrapperVTable->m_deleteData(pDBWrapper, table, &tmpField, 1, &tmpValue, 1);
	table  = "CarrierID";
	resultOV = pDBWrapperVTable->m_deleteData(pDBWrapper, table, &tmpField, 1, &tmpValue, 1);
	table  = "ExpressionSemantic";
	resultOV = pDBWrapperVTable->m_deleteData(pDBWrapper, table, &tmpField, 1, &tmpValue, 1);
	table  = "Relation";
	resultOV = pDBWrapperVTable->m_deleteData(pDBWrapper, table, &tmpField, 1, &tmpValue, 1);
	table  = "SubModel";
	resultOV = pDBWrapperVTable->m_deleteData(pDBWrapper, table, &tmpField, 1, &tmpValue, 1);
	ov_string_setvalue(&tmpValue, NULL);

	// Insert statements in database
	OV_STRING tmpFieldsStatements[7];
	tmpFieldsStatements[0] = "ComponentID";
	tmpFieldsStatements[1] = "CarrierID";
	tmpFieldsStatements[2] = "PropertyID";
	tmpFieldsStatements[3] = "ExpressionSemantic";
	tmpFieldsStatements[4] = "Relation";
	tmpFieldsStatements[5] = "Value";
	tmpFieldsStatements[6] = "SubModel";
	OV_STRING tmpValuesStatements[7];

	OV_STRING tmpFieldsList[2];
	tmpFieldsList[0] = "ComponentID";
	tmpFieldsList[1] = "Value";
	OV_STRING tmpValuesList[2];
	for (OV_UINT i = 0; i < statementsArraySize; i++){
		tmpValuesStatements[0] = NULL;
		tmpValuesList[0] = NULL;
		ov_string_print(&tmpValuesStatements[0], "%s", thisCl->v_ComponentID);
		ov_string_print(&tmpValuesList[0], "%s", thisCl->v_ComponentID);

		tmpValuesStatements[1] = NULL;
		ov_string_print(&tmpValuesStatements[1], "%s", statements[i].carrierID);
		tmpValuesList[1] = NULL;
		ov_string_print(&tmpValuesList[1], "%s", statements[i].carrierID);
		table = "CarrierID";
		resultOV = pDBWrapperVTable->m_insertData(pDBWrapper, table, tmpFieldsList, 2, tmpValuesList, 2);
		ov_string_setvalue(&tmpValuesList[1], NULL);

		tmpValuesStatements[2] = NULL;
		ov_string_print(&tmpValuesStatements[2], "%s", statements[i].propertyID);
		tmpValuesList[1] = NULL;
		ov_string_print(&tmpValuesList[1], "%s", statements[i].propertyID);
		table = "PropertyID";
		resultOV = pDBWrapperVTable->m_insertData(pDBWrapper, table, tmpFieldsList, 2, tmpValuesList, 2);
		ov_string_setvalue(&tmpValuesList[1], NULL);

		tmpValuesList[1] = NULL;
		tmpValuesStatements[3] = NULL;
		if (statements[i].expressionSemantic == NULL)
			ov_string_print(&tmpValuesStatements[3], "");
		else
			ov_string_print(&tmpValuesStatements[3], "%s", statements[i].expressionSemantic);
		tmpValuesList[1] = NULL;
		if (statements[i].expressionSemantic == NULL)
			ov_string_print(&tmpValuesList[1], "");
		else
			ov_string_print(&tmpValuesList[1], "%s", statements[i].expressionSemantic);
		table = "ExpressionSemantic";
		resultOV = pDBWrapperVTable->m_insertData(pDBWrapper, table, tmpFieldsList, 2, tmpValuesList, 2);
		ov_string_setvalue(&tmpValuesList[1], NULL);

		tmpValuesList[1] = NULL;
		tmpValuesStatements[4] = NULL;
		ov_string_print(&tmpValuesStatements[4], "%s", statements[i].relation);
		tmpValuesList[1] = NULL;
		ov_string_print(&tmpValuesList[1], "%s", statements[i].relation);
		table = "Relation";
		resultOV = pDBWrapperVTable->m_insertData(pDBWrapper, table, tmpFieldsList, 2, tmpValuesList, 2);
		ov_string_setvalue(&tmpValuesList[1], NULL);

		tmpValuesList[1] = NULL;
		tmpValuesStatements[5] = NULL;
		if (statements[i].value == NULL)
			ov_string_print(&tmpValuesStatements[5], "");
		else
			ov_string_print(&tmpValuesStatements[5], "%s", statements[i].value);

		tmpValuesList[1] = NULL;
		tmpValuesStatements[6] = NULL;
		ov_string_print(&tmpValuesStatements[6], "%s", statements[i].subModel);
		tmpValuesList[1] = NULL;
		ov_string_print(&tmpValuesList[1], "%s", statements[i].subModel);
		table = "SubModel";
		resultOV = pDBWrapperVTable->m_insertData(pDBWrapper, table, tmpFieldsList, 2, tmpValuesList, 2);
		ov_string_setvalue(&tmpValuesList[1], NULL);
		ov_string_setvalue(&tmpValuesList[0], NULL);

		if (ov_string_compare(statements[i].valueType, "Numeric") == OV_STRCMP_EQUAL){
			table = "statements_Numeric";
		}else{
			table = "statements_TextBoolean";
		}

		resultOV = pDBWrapperVTable->m_insertData(pDBWrapper, table, tmpFieldsStatements, 7, tmpValuesStatements, 7);
		for (OV_UINT i = 0; i < 7; i++){
			ov_string_setvalue(&tmpValuesStatements[i], NULL);
		}
		if (resultOV != OV_ERR_OK && resultOV != OV_ERR_ALREADYEXISTS){
			ov_logfile_error("Could not insert statements in database");
			goto FINALIZE;
		}
	}
	FINALIZE:
	Ov_SetDynamicVectorLength(&jsonTags, 0, STRING);
	Ov_SetDynamicVectorLength(&tokenIndex, 0, UINT);
	for (OV_UINT i = 0; i < statementsArraySize; i++){
		ov_string_setvalue(&statements[i].carrierID, NULL);
		ov_string_setvalue(&statements[i].propertyID, NULL);
		ov_string_setvalue(&statements[i].expressionSemantic, NULL);
		ov_string_setvalue(&statements[i].relation, NULL);
		ov_string_setvalue(&statements[i].value, NULL);
		ov_string_setvalue(&statements[i].valueType, NULL);
		ov_string_setvalue(&statements[i].subModel, NULL);
	}
	if (statements)
		free(statements);

	jsonData.js = NULL;
	json_data_deleteMembers(&jsonData);
	thisCl->v_isInUse = FALSE;
	return;
}

OV_DLLFNCEXPORT OV_RESULT AASCrawler_AASCrawlerC_crawlAAS(OV_INSTPTR_openAASDiscoveryServer_AASCrawler pinst) {
    /*
    *   local variables
    */
	OV_INSTPTR_openAASDiscoveryServer_DBWrapper pDBWrapper = NULL;
	OV_VTBLPTR_openAASDiscoveryServer_DBWrapper pDBWrapperVTable = NULL;
	OV_RESULT resultOV = OV_ERR_OK;
	OV_STRING table  = "Endpoints";
	OV_STRING fields[2] = {"ComponentID", "EndpointString"};
	OV_STRING whereFields = "ProtocolType";
	OV_STRING whereValues = "http";
	OV_STRING_VEC result;
	result.value = NULL;
	result.veclen = 0;
	if (!pinst->v_DBWrapperPath){
		ov_logfile_error("no dbwrapper path");
		return OV_ERR_GENERIC;
	}

	pDBWrapper = Ov_DynamicPtrCast(openAASDiscoveryServer_DBWrapper, ov_path_getobjectpointer(pinst->v_DBWrapperPath, 2));
	if (!pDBWrapper){
		ov_logfile_error("wrong dbwrapper path");
		return OV_ERR_GENERIC;
	}

	Ov_GetVTablePtr(openAASDiscoveryServer_DBWrapper,pDBWrapperVTable, pDBWrapper);
	resultOV = pDBWrapperVTable->m_selectData(pDBWrapper, table, fields, 2, &whereFields, 1, &whereValues, 1, &result);
	if (resultOV != OV_ERR_OK){
		ov_logfile_error("Internal Error: SQL error");
		return OV_ERR_GENERIC;
	}


	OV_INSTPTR_AASCrawler_AASHttpClient pClient = NULL;
	OV_INSTPTR_ov_object pObj = NULL;
	pObj = Ov_GetFirstChild(ov_containment, pinst);

	for (OV_UINT i = 0; i < result.veclen; i = i + 2){
		if (pObj){
			do{
				pClient = Ov_DynamicPtrCast(AASCrawler_AASHttpClient, pObj);
				if (pClient){
					if (pClient->v_isInUse == FALSE)
						break;
				}
				pObj = Ov_GetNextChild(ov_containment, pObj);
			}while(pObj);
		}
		if (!pObj){
			Ov_CreateIDedObject(AASCrawler_AASHttpClient, pClient, pinst, NULL);
		}
		ov_string_setvalue(&pClient->v_ComponentID, result.value[i]);
		pClient->v_isInUse = TRUE;
		OV_STRING tmpString = NULL;
		ov_string_setvalue(&tmpString, result.value[i+1]);
		ov_string_append(&tmpString, "/discovery");
		kshttp_genericHttpClient_sendHTTPRequest(Ov_DynamicPtrCast(kshttp_genericHttpClient, pClient), tmpString, AASCrawler_AASHttpClient_Callback);
		ov_string_setvalue(&tmpString, NULL);
		pClient = NULL;
		if (pObj)
			pObj = Ov_GetNextChild(ov_containment, pObj);
	}

    return resultOV;
}


