/******************************************************************************
 *
 *   FILE
 *   ----
 *   nodeStoreFunctions.c
 *
 *   History
 *   -------
 *   2014-10-21   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#ifndef OV_COMPILE_LIBRARY_lifeCycleEntryOPCUAInterface
#define OV_COMPILE_LIBRARY_lifeCycleEntryOPCUAInterface
#endif

#include "lifeCycleEntryOPCUAInterface.h"
#include "libov/ov_macros.h"
#include "ksbase.h"
#include "opcua.h"
#include "opcua_helpers.h"
#include "NoneTicketAuthenticator.h"
#include "libov/ov_path.h"
#include "libov/ov_memstack.h"
#include "ks_logfile.h"
#include "nodeset_lifeCycleEntry.h"

extern OV_INSTPTR_lifeCycleEntryOPCUAInterface_interface pinterface;




OV_DLLFNCEXPORT UA_StatusCode lifeCycleEntryOPCUAInterface_interface_ovLifeCycleEntriesNodeToOPCUA(
		void *handle, const UA_NodeId *nodeId, UA_Node** opcuaNode) {
	UA_Node 				*newNode = NULL;
	UA_StatusCode 			result = UA_STATUSCODE_GOOD;
	OV_PATH 				path;
	OV_INSTPTR_ov_object	pobj = NULL;
	OV_TICKET 				*pTicket = NULL;
	OV_VTBLPTR_ov_object	pVtblObj = NULL;
	OV_ACCESS				access;
	UA_NodeClass 			nodeClass;
	OV_STRING 				tmpString = NULL;
	OV_UINT 				len = 0;
	OV_UINT 				len2 = 0;
	OV_STRING 				*plist = NULL;
	OV_STRING 				*plist2 = NULL;
	OV_ELEMENT				element;

	if (pinterface == NULL)
		return UA_STATUSCODE_BADOUTOFSERVICE;

	copyOPCUAStringToOV(nodeId->identifier.string, &tmpString);
	plist = ov_string_split(tmpString, "|||", &len);
	plist2 = ov_string_split(plist[1], ".", &len2);
	ov_string_setvalue(&tmpString, NULL);

	UA_NodeId tmpNodeId;
	UA_NodeId_init(&tmpNodeId);
	tmpNodeId.namespaceIndex = nodeId->namespaceIndex;
	tmpNodeId.identifierType = nodeId->identifierType;

	tmpNodeId.identifier.string = UA_String_fromChars(plist[0]);

	ov_string_freelist(plist);
	ov_memstack_lock();
	result = opcua_nodeStoreFunctions_resolveNodeIdToPath(tmpNodeId, &path);
	if(result != UA_STATUSCODE_GOOD){
		ov_memstack_unlock();
		ov_string_freelist(plist2);
		return result;
	}
	element = path.elements[path.size-1];
	ov_memstack_unlock();

	result = opcua_nodeStoreFunctions_getVtblPointerAndCheckAccess(&element, pTicket, &pobj, &pVtblObj, &access);
	if(result != UA_STATUSCODE_GOOD){
		ov_string_freelist(plist2);
		return result;
	}

	nodeClass = UA_NODECLASS_OBJECT;
	newNode = (UA_Node*)UA_calloc(1, sizeof(UA_ObjectNode));


	// Basic Attribute
	// BrowseName
	UA_QualifiedName qName;
	qName.name = UA_String_fromChars("LifeCycleEntries");
	qName.namespaceIndex = nodeId->namespaceIndex;
	newNode->browseName = qName;

	// Description
	OV_STRING tempString = pVtblObj->m_getcomment(pobj, &element);
	UA_LocalizedText lText;
	UA_LocalizedText_init(&lText);
	lText.locale = UA_String_fromChars("en");
	if(tempString){
		lText.text = UA_String_fromChars(tempString);
	} else {
		lText.text = UA_String_fromChars("");
	}
	UA_LocalizedText_copy(&lText,&newNode->description);
	UA_LocalizedText_deleteMembers(&lText);

	// DisplayName
	UA_LocalizedText displayName;
	UA_LocalizedText_init(&displayName);
	displayName.locale = UA_String_fromChars("en");
	displayName.text = UA_String_fromChars("LifeCycleEntries");
	UA_LocalizedText_copy(&displayName, &newNode->displayName);
	UA_LocalizedText_deleteMembers(&displayName);

	// NodeId
	UA_NodeId_copy(nodeId, &newNode->nodeId);

	// NodeClass
	newNode->nodeClass 	= nodeClass;

	// WriteMask
	UA_UInt32 writeMask = 0;
	if(element.elemtype != OV_ET_VARIABLE){
		if(access & OV_AC_WRITE){
			writeMask |= (1<<2);	//	BrowseName
			writeMask |= (1<<6);	//	DisplayName
		}
		if(access & OV_AC_RENAMEABLE){
			writeMask |= (1<<14);	//	NodeId
		}
	}
	newNode->writeMask 	= writeMask;

	// Object specific attributes
	((UA_ObjectNode*)newNode)->eventNotifier = 0;


	// References
	UA_Node tmpNode;
	UA_NodeId_copy(&tmpNodeId, &tmpNode.nodeId);


	addReference(&tmpNode);
	UA_NodeId_deleteMembers(&tmpNodeId);
	tmpNodeId = UA_NODEID_NUMERIC(0, UA_NS0ID_HASTYPEDEFINITION);
	OV_UINT inverseCount = 0;
	for (size_t i = 0; i < tmpNode.referencesSize; i++){
		if (UA_NodeId_equal(&tmpNode.references[i].referenceTypeId, &tmpNodeId)){
			tmpNode.references[i].targetId = UA_EXPANDEDNODEID_NUMERIC(0, UA_NS0ID_FOLDERTYPE);
		}
		if (tmpNode.references[i].isInverse == TRUE){
			inverseCount = inverseCount + 1;
		}
	}

	newNode->referencesSize = tmpNode.referencesSize + 1 - inverseCount; // Parent
	newNode->references = UA_calloc(newNode->referencesSize, sizeof(UA_ReferenceNode));

	OV_UINT newReferenceCount = 0;
	for (size_t i = 0; i < tmpNode.referencesSize; i++){
		if (tmpNode.references[i].isInverse == FALSE){
			UA_NodeId_copy(&(tmpNode.references[i].referenceTypeId), &(newNode->references[newReferenceCount].referenceTypeId));
			UA_ExpandedNodeId_copy(&(tmpNode.references[i].targetId), &(newNode->references[newReferenceCount].targetId));
			newNode->references[newReferenceCount].isInverse = tmpNode.references[i].isInverse;
			newReferenceCount = newReferenceCount + 1;
		}
	}
	UA_Array_delete(tmpNode.references, tmpNode.referencesSize, &UA_TYPES[UA_TYPES_REFERENCENODE]);

	// ParentNode
	newNode->references[newReferenceCount].referenceTypeId = UA_NODEID_NUMERIC(0, UA_NS0ID_ORGANIZES);
	newNode->references[newReferenceCount].isInverse = UA_TRUE;
	len = 0;
	plist = NULL;
	tmpString = NULL;
	copyOPCUAStringToOV(nodeId->identifier.string, &tmpString);
	plist = ov_string_split(tmpString, "|||", &len);
	newNode->references[newReferenceCount].targetId = UA_EXPANDEDNODEID_STRING_ALLOC(pinterface->v_interfacenamespace.index, plist[0]);
	ov_string_freelist(plist);
	ov_string_setvalue(&tmpString, NULL);


	*opcuaNode = newNode;
	return UA_STATUSCODE_GOOD;
}

