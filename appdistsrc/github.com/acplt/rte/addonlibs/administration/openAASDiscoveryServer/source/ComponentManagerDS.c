
/******************************************************************************
*
*   FILE
*   ----
*   ComponentManager.c
*
*   History
*   -------
*   2017-05-19   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_openAASDiscoveryServer
#define OV_COMPILE_LIBRARY_openAASDiscoveryServer
#endif


#include "openAASDiscoveryServer.h"
#include "libov/ov_macros.h"
#include "MessageSys_helpers.h"
#include "fb_database.h"
#include "libov/ov_result.h"


OV_DLLFNCEXPORT OV_RESULT openAASDiscoveryServer_ComponentManagerDS_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_openAASDiscoveryServer_ComponentManagerDS pinst = Ov_StaticPtrCast(openAASDiscoveryServer_ComponentManagerDS, pobj);
    OV_RESULT    result;

    /* do what the base class does first */
    result = fb_functionblock_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */
    pinst->v_iexreq = TRUE;
	pinst->v_actimode = 1;
	OV_INSTPTR_fb_task pTaskParent = NULL;
	pinst->v_messageBoxIsFiFo = TRUE;
	pinst->v_messageBoxSize = 10;
	pTaskParent = (OV_INSTPTR_fb_task)fb_database_geturtask();
	if (pTaskParent != NULL){
		Ov_Link(fb_tasklist, pTaskParent, pinst);
	}
	else {
		ov_logfile_error("Cannot link StateMachine to tasklist", pinst->v_identifier);
	}


    return OV_ERR_OK;
}


static OV_INSTPTR_MessageSys_Message getNextMessage(OV_INSTPTR_openAASDiscoveryServer_ComponentManagerDS this) {
	OV_INSTPTR_ov_object child = NULL;

	//Check if we have a Message if(FiFo) else(Stack)
	if (this->v_messageBoxIsFiFo == TRUE) {
		// Get the first child that can be casted to Message.
		child = Ov_GetFirstChild(ov_containment, &this->p_INBOX);
		while (child && !Ov_CanCastTo(MessageSys_Message , child)) {
			child = Ov_GetNextChild(ov_containment, child);
		}
	} else {
		// Get the last child that can be casted to Message.
		child = Ov_GetLastChild(ov_containment, &this->p_INBOX);
		while (child && !Ov_CanCastTo(MessageSys_Message , child)) {
			child = Ov_GetPreviousChild(ov_containment, child);
		}
	}
	//After getting next child, because it might have been the outbox check if it is a valid child now.
	//If not jump out, because the only childs of ServiceAdministrator are messages or the single outbox.
	if (child == NULL || !Ov_CanCastTo(MessageSys_Message , child)) {
		return NULL;
	}
	return (OV_INSTPTR_MessageSys_Message) child;
}

OV_DLLFNCEXPORT void openAASDiscoveryServer_ComponentManagerDS_cleanupMessageBox(OV_INSTPTR_openAASDiscoveryServer_ComponentManagerDS this) {
	int nMessagesToDelete = 0;
	int nMessagesDeleted = 0;
	OV_INSTPTR_ov_object pChild = NULL;
	OV_INSTPTR_MessageSys_Message pMessageToDelete = NULL;

	// Calculate the number of messages to delete.
	Ov_ForEachChild(ov_containment, &this->p_INBOX, pChild) {
		if (Ov_CanCastTo(MessageSys_Message, pChild)) {
			nMessagesToDelete++;
		}
	}
	nMessagesToDelete = nMessagesToDelete - this->v_messageBoxSize;

	// Delete the messages.
	// TODO: To be optimized.
	while (nMessagesDeleted < nMessagesToDelete) {
		// Find a message to delete.
		pMessageToDelete = NULL;
		Ov_ForEachChild(ov_containment, &this->p_INBOX, pChild) {
			if (!Ov_CanCastTo(MessageSys_Message, pChild)) {
				continue;
			}
			if (this->v_messageBoxIsFiFo) {
				if (pMessageToDelete == NULL || ov_time_compare(&pMessageToDelete->v_creationtime, &pChild->v_creationtime) == OV_TIMECMP_AFTER) {
					pMessageToDelete = (OV_INSTPTR_MessageSys_Message) pChild;
				}
			} else {
				if (pMessageToDelete == NULL || ov_time_compare(&pMessageToDelete->v_creationtime, &pChild->v_creationtime) == OV_TIMECMP_BEFORE) {
					pMessageToDelete = (OV_INSTPTR_MessageSys_Message) pChild;
				}
			}
		}
		// Delete the message.
		Ov_DeleteObject(pMessageToDelete);
		nMessagesDeleted++;
	}
	return;
}



OV_DLLFNCEXPORT void openAASDiscoveryServer_ComponentManagerDS_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*    
    *   local variables
    */
	OV_INSTPTR_openAASDiscoveryServer_ComponentManagerDS pinst = Ov_StaticPtrCast(openAASDiscoveryServer_ComponentManagerDS, pfb);
	OV_INSTPTR_MessageSys_Message message = NULL;

	// First clean message box, so only up-to-date messages are handled.
	openAASDiscoveryServer_ComponentManagerDS_cleanupMessageBox(pinst);
	// Get the next message, if any.
	message = getNextMessage(pinst);
	if (message == NULL) {
		// Nothing to do.
		return;
	}

	// Decoding the Message
	OV_STRING messageContent = NULL;

	// XML Decoding
	if (strncmp(message->v_msgBody, "<bdy>", 5) != 0){ // <bdy> not found
		Ov_DeleteObject((OV_INSTPTR_ov_object) message);
		ov_logfile_info("ComponentManager: <bdy> not found in msg");
		return;
	}
	OV_UINT messageLength = ov_string_getlength(message->v_msgBody);
	if (strncmp(&message->v_msgBody[messageLength-6], "</bdy>", 6) != 0){ // </bdy> not found
		Ov_DeleteObject((OV_INSTPTR_ov_object) message);
		ov_logfile_info("ComponentManager: </bdy> not found in msg");
		return;
	}
	messageContent = Ov_HeapMalloc((messageLength-11+1)*sizeof(char));
	memcpy(messageContent, (message->v_msgBody+5), messageLength-11);
	messageContent[messageLength-11] = '\0';

	// Call getMessage() from DiscoveryServer
	OV_VTBLPTR_openAASDiscoveryServer_DiscoveryServer pVTable = NULL;
	OV_STRING errorMessage = NULL;
	Ov_GetVTablePtr(openAASDiscoveryServer_DiscoveryServer, pVTable, Ov_DynamicPtrCast(openAASDiscoveryServer_DiscoveryServer, pinst->v_pouterobject));
	pVTable->m_getMessage(Ov_DynamicPtrCast(openAASDiscoveryServer_DiscoveryServer, pinst->v_pouterobject), messageContent, &errorMessage);

	//TODO: Handle Errormessage
	if (errorMessage)
		ov_string_setvalue(&errorMessage, NULL);
	Ov_HeapFree(messageContent);
	// delete all used memory
	Ov_DeleteObject((OV_INSTPTR_ov_object) message);

	return;
}

