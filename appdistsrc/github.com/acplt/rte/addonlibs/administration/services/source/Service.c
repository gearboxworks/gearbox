
/******************************************************************************
*
*   FILE
*   ----
*   Service.c
*
*   History
*   -------
*   2017-09-22   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_services
#define OV_COMPILE_LIBRARY_services
#endif


#include "services.h"
#include "libov/ov_macros.h"


OV_DLLFNCEXPORT OV_ACCESS services_Service_getaccess(
	OV_INSTPTR_ov_object	pobj,
	const OV_ELEMENT		*pelem,
	const OV_TICKET			*pticket
) {
    /*
    *   local variables
    */

	switch(pelem->elemtype) {
		case OV_ET_VARIABLE:
			if(pelem->elemunion.pvar->v_offset >= offsetof(OV_INST_ov_object,__classinfo)) {
				if(pelem->elemunion.pvar->v_vartype == OV_VT_CTYPE)
					return OV_AC_NONE;
				else{
					if((pelem->elemunion.pvar->v_varprops & OV_VP_DERIVED)){
						if((pelem->elemunion.pvar->v_varprops & OV_VP_SETACCESSOR)){
							return OV_AC_READWRITE;
						} else {
							return OV_AC_READ;
						}
					} else {
						return OV_AC_READWRITE;
					}
				}
			}
		break;
		default:
		break;
	}

	return ov_object_getaccess(pobj, pelem, pticket);
}


OV_DLLFNCEXPORT OV_RESULT services_Service_execute_set(
    OV_INSTPTR_services_Service          pobj,
    const OV_BOOL  value
) {

	OV_RESULT result = OV_ERR_OK;
	if (value == TRUE){
		OV_VTBLPTR_services_Service pvtable;
		Ov_GetVTablePtr(services_Service, pvtable, pobj);

		// InputArguments & OutputArguments
		OV_ELEMENT tmpPart;
		tmpPart.elemtype = OV_ET_NONE;
		tmpPart.pobj = NULL;
		OV_ELEMENT tmpParrent;
		tmpParrent.pobj = Ov_StaticPtrCast(ov_object, pobj);
		tmpParrent.elemtype = OV_ET_OBJECT;
		OV_UINT sizeInput = 0;
		OV_UINT sizeOutput = 0;
		do {
			ov_element_getnextpart(&tmpParrent, &tmpPart, OV_ET_VARIABLE);
			if (tmpPart.elemtype == OV_ET_NONE)
				break;

			if (tmpPart.elemunion.pvar->v_flags == 256){ // InputFlag is set
				sizeInput++;
				continue;
			}
			if (tmpPart.elemunion.pvar->v_flags == 16384){ // OutputFlag is set
				sizeOutput++;
				continue;
			}
		} while(TRUE);



		void **inputs = malloc(sizeof(void*)*sizeInput);
		for (OV_UINT i = 0; i < sizeInput; i++){
			inputs[i] = NULL;
		}

		tmpPart.elemtype = OV_ET_NONE;
		tmpPart.pobj = NULL;
		OV_UINT countInputs = 0;
		do {
			ov_element_getnextpart(&tmpParrent, &tmpPart, OV_ET_VARIABLE);
			if (tmpPart.elemtype == OV_ET_NONE)
				break;
			if (tmpPart.elemunion.pvar->v_flags == 256){ // InputFlag is set
				switch (tmpPart.elemunion.pvar->v_vartype){
					case OV_VT_BOOL:
					case OV_VT_INT:
					case OV_VT_UINT:
					case OV_VT_SINGLE:
					case OV_VT_DOUBLE:
						break;
					case OV_VT_STRING:
						if (ov_string_compare(*(OV_STRING*)tmpPart.pvalue, "") == OV_STRCMP_EQUAL){
							free(inputs);
							return OV_ERR_BADPARAM;
						}
						break;
					case OV_VT_ANY:
						if (((OV_ANY*)tmpPart.pvalue)->value.vartype == OV_VT_STRING){
							if (ov_string_compare(((OV_ANY*)tmpPart.pvalue)->value.valueunion.val_string, "") == OV_STRCMP_EQUAL){
								free(inputs);
								return OV_ERR_BADPARAM;
							}
						}
						break;
					case OV_VT_BOOL_VEC:
					case OV_VT_INT_VEC:
					case OV_VT_UINT_VEC:
					case OV_VT_SINGLE_VEC:
					case OV_VT_DOUBLE_VEC:
						break;
					case OV_VT_STRING_VEC:
						for (OV_UINT k = 0; k < (*(OV_STRING_VEC*)(tmpPart.pvalue)).veclen; k++){
							if (ov_string_compare((*(OV_STRING_VEC*)(tmpPart.pvalue)).value[k], "") == OV_STRCMP_EQUAL){
								free(inputs);
								return OV_ERR_BADPARAM;
							}
						}
						break;
					default:
						break;
				}
				inputs[countInputs] = tmpPart.pvalue;
				countInputs++;
			}
			if (countInputs == sizeInput){
				break;
			}else{
				continue;
			}
		} while(TRUE);

		void **outputs = malloc(sizeof(void*)*sizeOutput);
		for (OV_UINT i = 0; i < sizeOutput; i++){
			outputs[i] = NULL;
		}

		OV_UINT *typeArray= ov_database_malloc(sizeof(OV_UINT)*sizeOutput);
		result = pvtable->m_CallMethod(pobj, sizeInput, (const void**)inputs, sizeOutput, outputs, typeArray);

		tmpPart.elemtype = OV_ET_NONE;
		tmpPart.pobj = NULL;
		OV_UINT countOutputs = 0;
		do {
			ov_element_getnextpart(&tmpParrent, &tmpPart, OV_ET_VARIABLE);
			if (tmpPart.elemtype == OV_ET_NONE)
				break;
			if (tmpPart.elemunion.pvar->v_flags == 16384){ // OutputFlag is set
				OV_ANY tmpAny;
				tmpAny.value.vartype = OV_VT_VOID;
				switch (tmpPart.elemunion.pvar->v_vartype){
					case OV_VT_BOOL:
						tmpAny.value.valueunion.val_bool = *(OV_BOOL*)(outputs[countOutputs]);
						tmpAny.value.vartype = OV_VT_BOOL;
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);
						break;
					case OV_VT_INT:
						tmpAny.value.valueunion.val_int = *(OV_INT*)(outputs[countOutputs]);
						tmpAny.value.vartype = OV_VT_INT;
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);
						break;
					case OV_VT_UINT:
						tmpAny.value.valueunion.val_uint = *(OV_UINT*)(outputs[countOutputs]);
						tmpAny.value.vartype = OV_VT_UINT;
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);
						break;
					case OV_VT_SINGLE:
						tmpAny.value.valueunion.val_single = *(OV_SINGLE*)(outputs[countOutputs]);
						tmpAny.value.vartype = OV_VT_SINGLE;
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);
						break;
					case OV_VT_DOUBLE:
						tmpAny.value.valueunion.val_double = *(OV_DOUBLE*)(outputs[countOutputs]);
						tmpAny.value.vartype = OV_VT_DOUBLE;
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);
						break;
					case OV_VT_STRING:
						tmpAny.value.valueunion.val_string = NULL;
						ov_string_setvalue(&tmpAny.value.valueunion.val_string, *(OV_STRING*)(outputs[countOutputs]));
						tmpAny.value.vartype = OV_VT_STRING;
						if (*(OV_STRING*)outputs[countOutputs])
							ov_database_free(*(OV_STRING*)outputs[countOutputs]);
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);

						break;
					case OV_VT_ANY:
						ov_variable_setanyvalue(&tmpAny, (OV_ANY*)(outputs[countOutputs]));
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);
						break;
					case OV_VT_BOOL_VEC:
						tmpAny.value.valueunion.val_bool_vec.value = NULL;
						tmpAny.value.valueunion.val_bool_vec.veclen = 0;
						Ov_SetDynamicVectorLength(&tmpAny.value.valueunion.val_bool_vec, (*(OV_BOOL_VEC*)(outputs[countOutputs])).veclen, BOOL);
						for (OV_UINT i = 0; i < (*(OV_BOOL_VEC*)(outputs[countOutputs])).veclen; i++){
							tmpAny.value.valueunion.val_bool_vec.value[i] = (*(OV_BOOL_VEC*)(outputs[countOutputs])).value[i];
						}
						tmpAny.value.vartype = OV_VT_BOOL_VEC;
						if ((*(OV_GENERIC_VEC*)(outputs[countOutputs])).value)
							ov_database_free((*(OV_GENERIC_VEC*)(outputs[countOutputs])).value);
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);
						break;
					case OV_VT_INT_VEC:
						tmpAny.value.valueunion.val_int_vec.value = NULL;
						tmpAny.value.valueunion.val_int_vec.veclen = 0;
						Ov_SetDynamicVectorLength(&tmpAny.value.valueunion.val_int_vec, (*(OV_INT_VEC*)(outputs[countOutputs])).veclen, INT);
						for (OV_UINT i = 0; i < (*(OV_INT_VEC*)(outputs[countOutputs])).veclen; i++){
							tmpAny.value.valueunion.val_int_vec.value[i] = (*(OV_INT_VEC*)(outputs[countOutputs])).value[i];
						}
						tmpAny.value.vartype = OV_VT_INT_VEC;
						if ((*(OV_GENERIC_VEC*)(outputs[countOutputs])).value)
							ov_database_free((*(OV_GENERIC_VEC*)(outputs[countOutputs])).value);
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);
						break;
					case OV_VT_UINT_VEC:
						tmpAny.value.valueunion.val_uint_vec.value = NULL;
						tmpAny.value.valueunion.val_uint_vec.veclen = 0;
						Ov_SetDynamicVectorLength(&tmpAny.value.valueunion.val_uint_vec, (*(OV_UINT_VEC*)(outputs[countOutputs])).veclen, UINT);
						for (OV_UINT i = 0; i < (*(OV_UINT_VEC*)(outputs[countOutputs])).veclen; i++){
							tmpAny.value.valueunion.val_uint_vec.value[i] = (*(OV_UINT_VEC*)(outputs[countOutputs])).value[i];
						}
						tmpAny.value.vartype = OV_VT_UINT_VEC;
						if ((*(OV_GENERIC_VEC*)(outputs[countOutputs])).value)
							ov_database_free((*(OV_GENERIC_VEC*)(outputs[countOutputs])).value);
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);
						break;
					case OV_VT_SINGLE_VEC:
						tmpAny.value.valueunion.val_single_vec.value = NULL;
						tmpAny.value.valueunion.val_single_vec.veclen = 0;
						Ov_SetDynamicVectorLength(&tmpAny.value.valueunion.val_single_vec, (*(OV_SINGLE_VEC*)(outputs[countOutputs])).veclen, SINGLE);
						for (OV_UINT i = 0; i < (*(OV_SINGLE_VEC*)(outputs[countOutputs])).veclen; i++){
							tmpAny.value.valueunion.val_single_vec.value[i] = (*(OV_SINGLE_VEC*)(outputs[countOutputs])).value[i];
						}
						tmpAny.value.vartype = OV_VT_SINGLE_VEC;
						if ((*(OV_GENERIC_VEC*)(outputs[countOutputs])).value)
							ov_database_free((*(OV_GENERIC_VEC*)(outputs[countOutputs])).value);
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);
						break;
					case OV_VT_DOUBLE_VEC:
						tmpAny.value.valueunion.val_double_vec.value = NULL;
						tmpAny.value.valueunion.val_double_vec.veclen = 0;
						Ov_SetDynamicVectorLength(&tmpAny.value.valueunion.val_double_vec, (*(OV_DOUBLE_VEC*)(outputs[countOutputs])).veclen, DOUBLE);
						for (OV_UINT i = 0; i < (*(OV_DOUBLE_VEC*)(outputs[countOutputs])).veclen; i++){
							tmpAny.value.valueunion.val_double_vec.value[i] = (*(OV_DOUBLE_VEC*)(outputs[countOutputs])).value[i];
						}
						tmpAny.value.vartype = OV_VT_DOUBLE_VEC;
						if ((*(OV_GENERIC_VEC*)(outputs[countOutputs])).value)
							ov_database_free((*(OV_GENERIC_VEC*)(outputs[countOutputs])).value);
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);
						break;
					case OV_VT_STRING_VEC:
						tmpAny.value.valueunion.val_string_vec.value = NULL;
						tmpAny.value.valueunion.val_string_vec.veclen = 0;
						Ov_SetDynamicVectorLength(&tmpAny.value.valueunion.val_string_vec, (*(OV_STRING_VEC*)(outputs[countOutputs])).veclen, STRING);
						for (OV_UINT i = 0; i < (*(OV_STRING_VEC*)(outputs[countOutputs])).veclen; i++){
							tmpAny.value.valueunion.val_string_vec.value[i] = NULL;
							ov_string_setvalue(&tmpAny.value.valueunion.val_string_vec.value[i], (*(OV_STRING_VEC*)(outputs[countOutputs])).value[i]);
						}
						tmpAny.value.vartype = OV_VT_STRING_VEC;
						if ((*(OV_STRING_VEC*)(outputs[countOutputs])).value)
							for (OV_UINT k = 0; k < (*(OV_STRING_VEC*)(outputs[countOutputs])).veclen; k++){
								ov_database_free(((*(OV_STRING_VEC*)(outputs[countOutputs])).value)[k]);
							}
						if ((*(OV_GENERIC_VEC*)(outputs[countOutputs])).value)
							ov_database_free((*(OV_GENERIC_VEC*)(outputs[countOutputs])).value);
						if (outputs[countOutputs])
							ov_database_free(outputs[countOutputs]);
						break;
					default:
						break;
				}

				pvtable->m_setvar(tmpPart.pobj, &tmpPart, &tmpAny);

				switch (tmpPart.elemunion.pvar->v_vartype){
					case OV_VT_BOOL:
					case OV_VT_INT:
					case OV_VT_UINT:
					case OV_VT_SINGLE:
					case OV_VT_DOUBLE:
						break;
					case OV_VT_STRING:
						ov_string_setvalue(&tmpAny.value.valueunion.val_string, NULL);
						break;
					case OV_VT_ANY:
						if (tmpAny.value.vartype == OV_VT_STRING)
							ov_string_setvalue(&tmpAny.value.valueunion.val_string, NULL);
						break;
					case OV_VT_BOOL_VEC:
						Ov_SetDynamicVectorLength(&tmpAny.value.valueunion.val_bool_vec, 0 , BOOL);
						break;
					case OV_VT_INT_VEC:
						Ov_SetDynamicVectorLength(&tmpAny.value.valueunion.val_int_vec, 0 , INT);
						break;
					case OV_VT_UINT_VEC:
						Ov_SetDynamicVectorLength(&tmpAny.value.valueunion.val_uint_vec, 0 , UINT);
						break;
					case OV_VT_SINGLE_VEC:
						Ov_SetDynamicVectorLength(&tmpAny.value.valueunion.val_single_vec, 0 , SINGLE);
						break;
					case OV_VT_DOUBLE_VEC:
						Ov_SetDynamicVectorLength(&tmpAny.value.valueunion.val_double_vec, 0 , DOUBLE);
						break;
					case OV_VT_STRING_VEC:
						Ov_SetDynamicVectorLength(&tmpAny.value.valueunion.val_string_vec, 0 , STRING);
						break;
					default:
						break;
				}
				countOutputs++;
			}
			if (countOutputs == sizeOutput){
				break;
			}else{
				continue;
			}
		} while(TRUE);
		ov_database_free(typeArray);
		free(outputs);
		free(inputs);
	}

    pobj->v_execute = value;
    return result;
}

OV_DLLFNCEXPORT OV_RESULT services_Service_CallMethod(
  OV_INSTPTR_services_Service pobj,
  OV_UINT numberofInputArgs,
  const void **packedInputArgList,
  OV_UINT numberofOutputArgs,
  void **packedOutputArgList,
  OV_UINT *typeArray
) {

    return OV_ERR_OK;
}

