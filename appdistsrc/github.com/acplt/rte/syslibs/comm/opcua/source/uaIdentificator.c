
/******************************************************************************
*
*   FILE
*   ----
*   uaIdentificator.c
*
*   History
*   -------
*   2014-10-13   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_opcua
#define OV_COMPILE_LIBRARY_opcua
#endif


#include "opcua.h"
#include "libov/ov_macros.h"
#include "libov/ov_result.h"
#include "opcua_config.h"
#include "opcua_helpers.h"
#include "ks_logfile.h"
#include "open62541.h"
#include "ksbase_helper.h"


OV_DLLFNCEXPORT OV_RESULT read_xdr_uint(UA_ByteString data, OV_UINT* offset, OV_UINT* value)
{
	if(!data.data)
		return OV_ERR_GENERIC;
	if(!value || !offset)
		return OV_ERR_BADPARAM;
	if(data.length < 4){
		return OV_ERR_BADVALUE;
	}
	if(*offset <= (OV_UINT) (data.length - 4))
	{
		/*	shift left is defined as multiplication with powers of 2
		 * so it does the same independent of endianess of host system	*/
		*value = (OV_UINT)(((data.data[*offset+3]) << 24)
		                 | ((data.data[*offset+2]) << 16)
		                 | ((data.data[*offset+1]) << 8)
		                 | ((data.data[*offset+0])));
		*offset += 4;
		return OV_ERR_OK;
	}

	return OV_ERR_GENERIC;
}

OV_DLLFNCEXPORT OV_RESULT read_xdr_string_tomemstack(UA_ByteString data, OV_UINT* offset, OV_STRING* value, OV_UINT* len)
{
	unsigned int i = 0;
	OV_UINT length = 0;

	if(!data.data)
		return OV_ERR_GENERIC;
	if(!value || !offset)
		return OV_ERR_BADPARAM;

	if(Ov_Fail(read_xdr_uint(data, offset, &length)))
		return OV_ERR_GENERIC;
	if(length > (OV_UINT)data.length){
		return OV_ERR_BADVALUE;
	}
	if(*offset <= (OV_UINT) (data.length - length))
	{
		*value = ov_memstack_alloc(length+1);
		if(!(*value))
			return OV_ERR_HEAPOUTOFMEMORY;

		//copy it to the buffer
		for(i=0; i<length; i++)
			(*value)[i] = data.data[*offset + i];
		(*value)[length] = '\0';

		//xdrs are aligned in 4byte blocks
		while(length%4)
			length++;
		*offset += length;
		if(len)
			*len = length;
		return OV_ERR_OK;
	}
	if(len)
		*len = 0;
	return OV_ERR_GENERIC;
}

OV_DLLFNCEXPORT OV_RESULT opcua_uaIdentificator_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*
    *   local variables
    */
    OV_INSTPTR_opcua_uaIdentificator pinst = Ov_StaticPtrCast(opcua_uaIdentificator, pobj);
    OV_RESULT    result;

    /* do what the base class does first */
    result = ov_object_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */
    return ov_string_setvalue(&(pinst->v_protocolID), KSOPC_IDENTIFIER);
}

OV_DLLFNCEXPORT OV_BOOL opcua_uaIdentificator_identify (
	OV_INSTPTR_ksbase_ProtocolIdentificator this,
	OV_INSTPTR_ksbase_Channel pchannel
) {
	OV_INSTPTR_opcua_uaIdentificator thisId = Ov_StaticPtrCast(opcua_uaIdentificator, this);
	UA_ByteString		msgSource = {.data = pchannel->v_inData.readPT, .length = ((pchannel->v_inData.data + pchannel->v_inData.length) - pchannel->v_inData.readPT)};
	OV_UINT				offset = 4;
	OV_UINT				msgLength;
	OV_UINT				dummy;
	OV_UINT				iterator;
	OV_UINT				cmpLength;
	OV_STRING			tempStr = NULL;

	KS_logfile_debug(("%s: identify called with length: %u - data\n%s", thisId->v_identifier, msgSource.length, msgSource.data));

	cmpLength = ov_string_getlength(thisId->v_ident);
	if(cmpLength == 0){
		KS_logfile_debug(("%s: ident not set", thisId->v_identifier));
		return FALSE;
	}
	if(msgSource.length <= 0){
		KS_logfile_debug(("%s: msgSource.length not positive", thisId->v_identifier));
		return FALSE;
	}
	for(iterator = 0; iterator < (OV_UINT)(cmpLength - 1) && iterator < (OV_UINT)msgSource.length; iterator++){
		if(msgSource.data[iterator] != thisId->v_ident[iterator]){
			KS_logfile_debug(("%s: first bytes in Message do not match ident", thisId->v_identifier));
			return FALSE;
		}
	}

	if(read_xdr_uint(msgSource, &offset, &msgLength) != OV_ERR_OK){
		KS_logfile_debug(("%s: could not decode length in HelloMessage header", thisId->v_identifier));
		return FALSE;
	}

	if(msgLength != (OV_UINT)msgSource.length){
		KS_logfile_debug(("%s: length field in HelloMessage Header does not match length of Message", thisId->v_identifier));
		return FALSE;
	}
/*	this is a hello message.....
 *	UA_TYPES_UINT32, protocolVersion
	UA_TYPES_UINT32, receiveBufferSize
	UA_TYPES_UINT32, sendBufferSize
	UA_TYPES_UINT32, maxMessageSize
	UA_TYPES_UINT32, maxChunkCount
	UA_TYPES_STRING, endpointUrl
 * 	*/
	if(read_xdr_uint(msgSource, &offset, &dummy) != OV_ERR_OK){
		//OPC UA Part 6, Hello Message:The Server shall always accept versions greater than what it supports.
		KS_logfile_debug(("%s: could not decode protocolVersion in HelloMessage header", thisId->v_identifier));
		return FALSE;
	}
	if(read_xdr_uint(msgSource, &offset, &dummy) != OV_ERR_OK || dummy < 8192){
		//OPC UA Part 6, Hello Message: This value shall be greater than 8 192 bytes.
		KS_logfile_debug(("%s: could not decode receiveBufferSize in HelloMessage header (or < 8192)", thisId->v_identifier));
		return FALSE;
	}
	if(read_xdr_uint(msgSource, &offset, &dummy) != OV_ERR_OK || dummy < 8192){
		//OPC UA Part 6, Hello Message: This value shall be greater than 8 192 bytes.
		KS_logfile_debug(("%s: could not decode sendBufferSize in HelloMessage header (or < 8192)", thisId->v_identifier));
		return FALSE;
	}
	if(read_xdr_uint(msgSource, &offset, &dummy) != OV_ERR_OK){
		//OPC UA Part 6, Hello Message: A value of zero indicates that the Client has no limit.
		KS_logfile_debug(("%s: could not decode maxMessageSize in HelloMessage header", thisId->v_identifier));
		return FALSE;
	}
	if(read_xdr_uint(msgSource, &offset, &dummy) != OV_ERR_OK){
		//OPC UA Part 6, Hello Message: A value of zero indicates that the Client has no limit.
		KS_logfile_debug(("%s: could not decode maxChunkCount in HelloMessage header", thisId->v_identifier));
		return FALSE;
	}
	ov_memstack_lock();
	if(read_xdr_string_tomemstack(msgSource, &offset, &tempStr, &dummy) != OV_ERR_OK || dummy == 0){
		ov_memstack_unlock();
		KS_logfile_debug(("%s: could not decode endpointUrl in HelloMessage header (or length mismatch)", thisId->v_identifier));
		return FALSE;
	}
	ov_memstack_unlock();
	return TRUE;
}


OV_DLLFNCEXPORT OV_RESULT opcua_uaIdentificator_createClientHandler (
	OV_INSTPTR_ksbase_ProtocolIdentificator this,
	OV_INSTPTR_ksbase_Channel pchannel
) {
    /*
    *   local variables
    */
	OV_INSTPTR_opcua_uaConnection pClientHandler = NULL;

	OV_RESULT result;
	KS_logfile_debug(("%s: creating uaClientHandler...", this->v_identifier));

	result = Ov_CreateIDedObject(opcua_uaConnection, pClientHandler, this, "OPC_UAClientHandler");
	if(Ov_OK(result))
	{
		KS_logfile_debug(("%s: ClientHandler created: %s", this->v_identifier, pClientHandler->v_identifier));
		result = Ov_Link(ksbase_AssocChannelClientHandler, pchannel, pClientHandler);
		if(Ov_Fail(result))
		{
			KS_logfile_error(("%s: could not link ClientHandler %s to Channel %s", this->v_identifier, pClientHandler->v_identifier, pchannel->v_identifier));
			return result;
		}
		else
		{
			result = ov_string_setvalue(&(pClientHandler->v_sourceAdr), pchannel->v_address);
			if(Ov_Fail(result))
			{
				KS_logfile_error(("%s: could not set ClientHandler %s's sourceAdr. reason: %s", this->v_identifier, pClientHandler->v_identifier, ov_result_getresulttext(result)));
			}
		}
		result = Ov_Link(opcua_networkLayerToConnection, getOvNetworkLayer(), pClientHandler);
		if(Ov_Fail(result))
		{
			KS_logfile_error(("%s: could not link ClientHandler %s to networkLayer %s", this->v_identifier, pClientHandler->v_identifier, getOvNetworkLayer()->v_identifier));
			return result;
		} else {
			return OV_ERR_OK;
		}
	}
	else
	{
		KS_logfile_error(("%s: could not create ClientHandler: %s", this->v_identifier, ov_result_getresulttext(result)));
		return result;
	}
}
