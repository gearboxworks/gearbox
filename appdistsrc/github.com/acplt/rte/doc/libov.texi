\input texinfo   @c -*-texinfo-*-

@c	==============
@c	Part 1: Header
@c	==============

@c %**start of header

@setfilename libov.info
@settitle LibOV API Reference

@iftex
@afourpaper
@parindent=0pt
@end iftex

@c %**end of header

@c	=========================================
@c	Part 2: Summary Description and Copyright
@c	=========================================

@ifinfo
This file is a reference to the ACPLT/OV Object Management Library LibOV (Version 2.0).

Copyright @copyright{} 1998-2016 Lehrstuhl fuer Prozessleittechnik,
RWTH Aachen, D-52064 Aachen, Germany. All rights reserved.
@end ifinfo

@c	===============================
@c	Part 3: Titlepage and Copyright
@c	===============================

@ifnotinfo
@finalout	@c prevent TeX from drawing a black box whereever an overfull hbox occurs
@titlepage
@title LibOV API Reference
@author Dirk Meyer @code{<dirk@@plt.rwth-aachen.de>}@*
Christian Poensgen @code{<christian@@plt.rwth-aachen.de>}

@page
Copyright @copyright{} 1998-2016 Lehrstuhl fuer Prozessleittechnik,
RWTH Aachen, D-52056 Aachen, Germany. All rights reserved.
@end titlepage
@end ifnotinfo

@c	==================================
@c	Part 4: `Top' Node and Master Menu
@c	==================================

@node Top, Index, (dir), (dir)
@ifnotinfo
@c @node Top, Index, (dir), (dir)
@end ifnotinfo
@top LibOV API Reference (Version 1.2.1)
@ifnottex
@c @author Dirk Meyer @code{<dirk@@plt.rwth-aachen.de>}@*
Christian Poensgen @code{<christian@@plt.rwth-aachen.de>}
@end ifnottex


@menu
* Preprocessor symbols::  Preprocessor symbols used in the library.
* Import/Export::         Import and Export of functions and global variables.
* Debugging macros::      Debugging macros used in the library.
* Useful macros::         Useful macros easing the use of the library.
* Fundamental datatypes:: Fundamental datatypes used in the library.

* Index::		  Index
* License::               Legal terms and conditions.

* Association::           Functions and macros associated with associations.
* Class::                 Datatypes and functions associated with classes.
* Database::              Functions associated with the database.
* Element::               Datatypes and functions associated with elements.
* Library::               Functions associated with libraries.
* Logfile::               Functions associated with logfiles.
* Malloc::                Memory management functions for the system heap memory.
* Memstack::              Memory management functions for the memory stack.
* Object::                Datatypes and functions associated with objects (top level class).
* Operation::             Functions associated with operations.
* Part::                  Functions associated with parts.
* Path::                  Datatypes and functions associated with paths.
* Result::                Functions associated with results of function calls.
* Scheduler::             Datatypes and functions associated with the scheduler.
* String::                Functions associated with string variables.
* Structure::             Functions associated with structures.
* Supervise::             Execution time supervision functions.
* Time::                  Functions associated with time variables.
* Variable::              Functions associated with variables.
* Vector::                Functions associated with vector variables.
* Vendortree::            Functions associated with the vendor tree.
@end menu

@ifnottex
@ifnotinfo
@node Index, License, Top, Top
@chapter Index
@end ifnotinfo
@end ifnottex

@ifinfo
The following subjects are available:
@end ifinfo

@c @menu
@c * License::               Legal terms and conditions.
@c @end menu

@c @menu
@c * Preprocessor symbols::  Preprocessor symbols used in the library.
@c * Import/Export::         Import and Export of functions and global variables.
@c * Debugging macros::      Debugging macros used in the library.
@c * Useful macros::         Useful macros easing the use of the library.
@c * Fundamental datatypes:: Fundamental datatypes used in the library.
@c @end menu

@c @menu
@c * Association::           Functions and macros associated with associations.
@c * Class::                 Datatypes and functions associated with classes.
@c * Database::              Functions associated with the database.
@c * Element::               Datatypes and functions associated with elements.
@c * Library::               Functions associated with libraries.
@c * Logfile::               Functions associated with logfiles.
@c * Malloc::                Memory management functions for the system heap memory.
@c * Memstack::              Memory management functions for the memory stack.
@c * Object::                Datatypes and functions associated with objects (top level class).
@c * Operation::             Functions associated with operations.
@c * Part::                  Functions associated with parts.
@c * Path::                  Datatypes and functions associated with paths.
@c * Result::                Functions associated with results of function calls.
@c * Scheduler::             Datatypes and functions associated with the scheduler.
@c * String::                Functions associated with string variables.
@c * Structure::             Functions associated with structures.
@c * Supervise::             Execution time supervision functions.
@c * Time::                  Functions associated with time variables.
@c * Variable::              Functions associated with variables.
@c * Vector::                Functions associated with vector variables.
@c * Vendortree::            Functions associated with the vendor tree.
@c @end menu

@c	================================
@c	Part 5: The Body of the Document
@c	================================

@c	-------
@c	License
@c	-------

@node License, Preprocessor symbols, Index, Top
@chapter Legal terms and conditions

Copyright @copyright{} 1998-2016@*
Lehrstuhl fuer Prozessleittechnik,@*
RWTH Aachen, D-52056 Aachen, Germany.@*
All rights reserved.

The ACPLT/OV Package is licensed as open source under the Artistic License; 
you can use, redistribute and/or modify it under the terms of that license.

You should have received a copy of the Artistic License along with this
Package; see the file ARTISTIC-LICENSE. If not, write to the Copyright Holder.

THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND 
FITNESS FOR A PARTICULAR PURPOSE.

@c	--------------------
@c	Preprocessor symbols
@c	--------------------

@node Preprocessor symbols, Import/Export, License, Top
@chapter Preprocessor symbols used in the library

When compiling the object management library the following preprocessor
symbols are used:
@menu
* OV_COMPILER_XXX::      Definition of the compiler used.
* OV_SYSTEM_XXX::        Definition of the target operating system.
* OV_DEBUG::             Definition whether debugging features are used.
* OV_STATIC_LIBRARIES::  Definition whether static libraries are used.
* OV_DYNAMIC_LIBRARIES:: Definition whether dynamic libraries are used.
* OV_DYNAMIC_DATABASE::  Definition whether dynamically growing databases are used.
@end menu

@c	--------------------------------

@node OV_COMPILER_XXX, OV_SYSTEM_XXX, Preprocessor symbols, Preprocessor symbols
@section Definition of the compiler used

The preprocessor symbol @code{OV_COMPILER_@emph{COMPILER}} defines which compiler 
is used (symbol is defined as @code{1}) and which ones not (symbol is defined 
as @code{0}). 

For instance, if you are compiling using the Borland compiler, the following 
symbols are defined:

@format
@t{#define OV_COMPILER_BORLAND 1
#define OV_COMPILER_CYGWIN  0
#define OV_COMPILER_GCC     0}
@end format

These symbols are automatically defined in the configuration header file 
@code{libov/ov_config.h}.

Available Symbols:
@format
@t{OV_COMPILER_CYGWIN
OV_COMPILER_GCC
OV_COMPILER_MSVC
OV_COMPILER_BORLAND
OV_COMPILER_KEIL
OV_COMPILER_DECCXX}
@end format

@c	--------------------------------

@node OV_SYSTEM_XXX, OV_DEBUG, OV_COMPILER_XXX, Preprocessor symbols
@section Definition of the target operating system

The preprocessor symbol @code{OV_SYSTEM_@emph{SYSTEM}} defines for which 
target operating system the library is compiled (symbol is defined as 
@code{1}) and for which ones not (symbol is defined as @code{0}). 

If the target operating system is any Unix system (e.g. Linux, HP-UX, 
Solaris, ...), the more generic symbol @code{OV_SYSTEM_UNIX} is defined 
as @code{1} and defined as @code{0} otherwise. 

For instance, if you are compiling on a Linux system, the following 
symbols are defined:

@format
@t{#define OV_SYSTEM_UNIX  1
#define OV_SYSTEM_LINUX 1
#define OV_SYSTEM_NT    0}
@end format

Usually, you should define the appropriate target operating system when
calling the compiler, e.g.

@code{gcc -Wall -O2 -DOV_SYSTEM_LINUX=1 -c foo.c -o foo.o}

All @code{OV_SYSTEM_@emph{SYSTEM}} symbols not defined are automatically
defined as @code{0} in the configuration header file 
@code{libov/ov_config.h}.

Available Symbols:
@format
@t{OV_SYSTEM_NT
OV_SYSTEM_HPUX
OV_SYSTEM_LINUX
OV_SYSTEM_OPENVMS
OV_SYSTEM_SOLARIS
OV_SYSTEM_MC164
OV_SYSTEM_RMOS}
@end format

@c	--------------------------------

@node OV_DEBUG, OV_STATIC_LIBRARIES, OV_SYSTEM_XXX, Preprocessor symbols
@section Definition whether debugging features are used

The preprocessor sysmbol @code{OV_DEBUG} defines if you want to use the 
ACPLT/OV debugging features defined in the header file 
@code{libov/ov_debug.h}. If you define this symbol, the debugging macros 
log debugging information to the logfile. If you do not define this symbol, 
the debugging macros are ignored during compilation. 

For example, the compiler call

@code{gcc -Wall -O2 -DOV_SYSTEM_LINUX=1 -DOV_DEBUG -c foo.c -o foo.o}

compiles using the debugging features.

You may also define @code{OV_DEBUG} in your source file:

@format
@t{/*
*   foo.c
*/

#define OV_DEBUG

#include "libov/ov_ov.h"
#include <stdio.h>

void foo(
    OV_STRING   text
) @{
    Ov_WarnIfNot(text); /* warn if text is NULL */
    printf(text);
@}}
@end format

Make sure, that you define the symbol @strong{before} including any ACPLT/OV
header files!

@c	--------------------------------

@node OV_STATIC_LIBRARIES, OV_DYNAMIC_LIBRARIES, OV_DEBUG, Preprocessor symbols
@section Definition whether static libraries are used

The preprocessor symbol @code{OV_STATIC_LIBRARIES} defines whether there are 
ACPLT/OV libraries statically linked to the application (symbol is defined 
as @code{1}) or not (symbol is defined as @code{0}).

Usually if the target operating system supports dynamic linking (DLLs on
Windows NT, shared libraries on Unix systems), this symbol is defined as
@code{0}), because you get the advantage, that you do not have to determine
the libraries available for the application at link time but can load them
at run time.

This symbol is automatically defined in the configuration header file 
@code{libov/ov_config.h}.

@c	--------------------------------

@node OV_DYNAMIC_LIBRARIES, OV_DYNAMIC_DATABASE, OV_STATIC_LIBRARIES, Preprocessor symbols
@section Definition whether dynamic libraries are used

The preprocessor symbol @code{OV_DYNAMIC_LIBRARIES} defines whether ACPLT/OV 
libraries can by dynamically linked to the application (symbol is defined 
as @code{1}) or not (symbol is defined as @code{0}). 

This symbol can only be defined as @code{1} if the target operating 
supports dynamic linking or you are unable to compile the file 
@code{libov/ov_library.c}.

Usually if the target operating system supports dynamic linking (DLLs on
Windows NT, shared libraries on Unix systems), this symbol is defined as
@code{1}), because you get the advantage, that you do not have to determine
the libraries available for the application at link time but can load them
at run time.

This symbol is automatically defined in the configuration header file 
@code{libov/ov_config.h}.

@node OV_DYNAMIC_DATABASE, , OV_DYNAMIC_LIBRARIES, Preprocessor symbols
@section Definition whether dynamically growing databases are used

The preprocessor symbol @code{OV_DYNAMIC_DATABASE} defines whether ACPLT/OV 
databases may dynamically grow when memory is allocated (symbol is defined 
as @code{1}) or not (symbol is defined as @code{0}). 

@c	-------------
@c	Import/Export
@c	-------------

@node Import/Export, Debugging macros, Preprocessor symbols, Top
@chapter Import/Export of functions and global variables

In order to generate storage class modifiers for importing and exporting 
functions and global variables from a dynamically linked library (DLL),
the following preprocessor symbols are used:
@menu
* OV_DLLFNCEXPORT::  Modifier for functions that are exported from a DLL.
* OV_DLLVAREXPORT::  Modifier for global variables that are exported from a DLL.
* OV_DLLVARIMPORT::  Modifier for global variables that are imported from a DLL.
* OV_COMPILE_LIBOV:: Definition whether a LibOV source file is compiled.
@end menu

@c	--------------------------------

@node OV_DLLFNCEXPORT, OV_DLLVAREXPORT, Import/Export, Import/Export
@section Modifier for functions that are exported from a DLL

The preprocessor symbol @code{OV_DLLFNCEXPORT} is used to tell the compiler, 
that a function needs to be exported from a DLL. Using this symbol you do not 
need a module definition file (@code{.def}-file) listing all functions to be 
exported from a DLL.

This symbol is automatically defined in the configuration header file 
@code{libov/ov_config.h}.

@strong{Example}

The following piece of code defines a DLL function which may be used by
other modules linking to the import library of the DLL:

@format
@t{/*
*   hello.c
*/

#include "libov/ov_ov.h"
#include <stdio.h>

OV_DLLFNCEXPORT void hello(
    OV_STRING   name
) @{
    printf("hello %s\n", name);
@}}
@end format

@strong{Remarks}

Note, that you need to use this modifier in the declaration of function
prototypes as well (compare file @code{ov.ovf})!

@c	--------------------------------

@node OV_DLLVAREXPORT, OV_DLLVARIMPORT, OV_DLLFNCEXPORT, Import/Export
@section Modifier for global variables that are exported from a DLL

The preprocessor symbol @code{OV_DLLVAREXPORT} is used to tell the compiler, 
that a global variable is exported from a DLL.

This symbol is automatically defined in the configuration header file 
@code{libov/ov_config.h}.

@strong{Example}

The following piece of code defines a global variable which is exported from a DLL:

@format
@t{/*
*   foo.c
*/

#include "libov/ov_ov.h"
#include <stdio.h>

/*
*   the exported global variable
*/
OV_DLLVAREXPORT OV_STRING pstring;

/*
*   a function setting and printing the global variable
*/
void foo(void) @{
    pstring = "hello world";
    printf("pstring = %s\n", pstring);
@}}
@end format

A module using the DLL can access this variable using the preprocessor symbol
@code{OV_DLLVARIMPORT}.

@c	--------------------------------

@node OV_DLLVARIMPORT, OV_COMPILE_LIBOV, OV_DLLVAREXPORT, Import/Export
@section Modifier for global variables that are exported from a DLL

The preprocessor symbol @code{OV_DLLVARIMPORT} is to tell the compiler, that 
a global variable is imported from a DLL.

This symbol is automatically defined in the configuration header file 
@code{libov/ov_config.h}.

@strong{Example}

The following piece of code declares a global variable which is imported from a DLL:

@format
@t{/*
*   bar.c
*/

#include "libov/ov_ov.h"
#include <stdio.h>

/*
*   the imported global variable
*/
OV_DLLVARIMPORT OV_STRING pstring;

/*
*   a function setting and printing the global variable
*/
void bar(void) @{
    pstring = "hello world";
    printf("pstring = %s\n", pstring);
@}}
@end format

A module using the DLL can access this variable using the preprocessor symbol
@code{OV_DLLVARIMPORT}.

@c	--------------------------------

@node OV_COMPILE_LIBOV, , OV_DLLVARIMPORT, Import/Export
@section Definition whether a LibOV source file is compiled

The preprocessor symbol @code{OV_COMPILE_LIBOV} defines whether a source file
(module) of the ACPLT/OV Object Management Library LibOV itself is compiled
(symbol is defined as @code{1}) or not (symbol is defined as @code{0}). 

This symbol is necessary for Windows NT in order to determine whether global
variables need to be exported (symbol is defined as @code{1}) or imported
(symbol is defined as @code{0}) from a DLL.

@strong{Always} define this symbol if you add source files to the ACPLT/OV 
Object Management Library LibOV and @strong{never} define it in any other 
file! 

If you define the symbol, make sure that you define the symbol @strong{before} 
including any ACPLT/OV header files!

@c	----------------
@c	Debugging macros
@c	----------------

@node Debugging macros, Useful macros, Import/Export, Top
@chapter Debugging macros used in the library

In debugging mode (@code{OV_DEBUG} defined) the following macros are available, otherwise they do not
take effect:

@menu
* Ov_Info()::               Print information.
* Ov_Warning()::            Print a warning and continue.
* Ov_Error()::              Print an error and abort.
* Ov_WarnIf()::             Print a warning if a condition holds.
* Ov_WarnIfNot()::          Print a warning if a condition does not hold.
* Ov_AbortIf()::            Print an error if a condition holds and abort.
* Ov_AbortIfNot()::         Print an error if a condition does not hold and abort.
@end menu

@c	--------------------------------

@node Ov_Info(), Ov_Warning(), Debugging macros, Debugging macros
@section Print debug information

If @code{OV_DEBUG} is defined, this macro logs a user-defined debugging message: 

@code{[ACPLT/OV Debug] @emph{file}:@emph{line}: Info: @emph{info}}

@strong{Header file}

@code{#include "libov/ov_debug.h"}

@strong{Macro usage}

@code{Ov_Info(info);}

@strong{Parameters}

@table @code
@item info
String containing the info message.

@end table

@strong{Return value}

none

@c	--------------------------------

@node Ov_Warning(), Ov_Error(), Ov_Info(),  Debugging macros
@section Print a warning and continue

In debugging mode (@code{OV_DEBUG} defined) this macro logs a user-defined debugging message: 

@code{[ACPLT/OV Debug] @emph{file}:@emph{line}: Warning: @emph{warning}}

@strong{Header file}

@code{#include "libov/ov_debug.h"}

@strong{Macro usage}

@code{Ov_Warning(warning);}

@strong{Parameters}

@table @code
@item warning
String containing the warning message.

@end table

@strong{Return value}

none

@c	--------------------------------

@node Ov_Error(), Ov_WarnIf(), Ov_Warning(), Debugging macros
@section Print an error and abort

In debugging mode (@code{OV_DEBUG} defined) this macro logs a user-defined debugging message: 

@code{[ACPLT/OV Debug] @emph{file}:@emph{line}: Error: @emph{err}}

@strong{Header file}

@code{#include "libov/ov_debug.h"}

@strong{Macro usage}

@code{Ov_Error(err);}

@strong{Parameters}

@table @code
@item err
String containing the error message.

@end table

@strong{Return value}

none

@c	--------------------------------

@node Ov_WarnIf(), Ov_WarnIfNot(), Ov_Error(), Debugging macros
@section Print a warning if a condition holds

In debugging mode (@code{OV_DEBUG} defined) this macro logs a user-defined debugging message,
if condition specified is TRUE: 

@code{[ACPLT/OV Debug] @emph{file}:@emph{line}: Warning: Assertion failed: "!(@emph{condition})".}

@strong{Header file}

@code{#include "libov/ov_debug.h"}

@strong{Macro usage}

@code{Ov_WarnIf(condition);}

@strong{Parameters}

@table @code
@item condition
Conditional expression; if TRUE, a warning is printed.

@end table

@strong{Return value}

none

@c	--------------------------------

@node Ov_WarnIfNot(), Ov_AbortIf(), Ov_WarnIf(), Debugging macros
@section Print a warning if a condition does not hold

@strong{Header file}

In debugging mode (@code{OV_DEBUG} defined) this macro logs a user-defined debugging message,
if condition specified is FALSE: 

@code{[ACPLT/OV Debug] @emph{file}:@emph{line}: Warning: Assertion failed: "(@emph{condition})".}

@code{#include "libov/ov_debug.h"}

@strong{Macro usage}

@code{Ov_WarnIfNot(condition);}

@strong{Parameters}

@table @code
@item condition
Conditional expression; if FALSE, a warning is printed.

@end table

@strong{Return value}

none

@c	--------------------------------

@node Ov_AbortIf(), Ov_AbortIfNot(), Ov_WarnIfNot(), Debugging macros
@section Print an error if a condition holds and abort

In debugging mode (@code{OV_DEBUG} defined) this macro logs a user-defined debugging message,
if condition specified is TRUE and aborts the process: 

@code{[ACPLT/OV Debug] @emph{file}:@emph{line}: Error: Assertion failed: "!(@emph{condition})".}

@strong{Header file}

@code{#include "libov/ov_debug.h"}

@strong{Macro usage}

@code{Ov_AbortIf(condition);}

@strong{Parameters}

@table @code
@item condition
Conditional expression; if TRUE, the process is aborted with a message.

@end table

@strong{Return value}

none

@c	--------------------------------

@node Ov_AbortIfNot(), , Ov_AbortIf(), Debugging macros
@section Print an error if a condition does not hold and abort

In debugging mode (@code{OV_DEBUG} defined) this macro logs a user-defined debugging message,
if condition specified is FALSE and aborts the process: 

@code{[ACPLT/OV Debug] @emph{file}:@emph{line}: Error: Assertion failed: "(@emph{condition})".}

@strong{Header file}

@code{#include "libov/ov_debug.h"}

@strong{Macro usage}

@code{Ov_AbortIfNot(condition);}

@strong{Parameters}

@table @code
@item condition
Conditional expression; if FALSE, the process is aborted with a message.

@end table

@strong{Return value}

none

@c	-------------
@c	Useful macros
@c	-------------

@node Useful macros, Fundamental datatypes, Debugging macros, Top
@chapter Useful macros easing the use of the library

@menu
* Ov_ParentPtrUpCast()::          Upcast of an instance pointer of the parent class.
* Ov_ChildPtrUpCast()::           Upcast of an instance pointer of the child class.
* Ov_GetFirstChild()::            Get first child in a 1:n association.
* Ov_GetLastChild()::             Get last child in a 1:n association.
* Ov_GetNextChild()::             Get next child in a 1:n association.
* Ov_GetPreviousChild()::         Get previous child a 1:n association.
* Ov_GetParent()::                Get parent in a 1:n association.
* Ov_ForEachChild()::             Iterate over all child objects in a 1:n association.
* Ov_ForEachChildEx()::           Iterate over all child objects in a 1:n association and dynamically cast to a given child class.
* Ov_SearchChild()::              Search a child with given identifier in a 1:n association.
* Ov_SearchChildEx()::            Search a child with given identifier and cast to child class in a 1:n association.
* Ov_DefineIteratorNM()::         Define an iterator for iterating over n:m associations.
* Ov_GetFirstChildNM()::          Get first child in an n:m association.
* Ov_GetLastChildNM()::           Get last child in an n:m association.
* Ov_GetNextChildNM()::           Get next child in an n:m association.
* Ov_GetPreviousChildNM()::       Get previous child in an n:m association.
* Ov_GetFirstParentNM()::         Get first parent in an n:m association.
* Ov_GetLastParentNM()::          Get last parent in an n:m association.
* Ov_GetNextParentNM()::          Get next parent in an n:m association.
* Ov_GetPreviousParentNM()::      Get previous parent in an n:m association.
* Ov_ForEachChildNM()::           Iterate over all child objects in an n:m association.
* Ov_ForEachChildNMEx()::         Iterate over all child objects in an n:m association and dynamically cast to a given child class.
* Ov_ForEachParentNM()::          Iterate over all parent objects in an n:m association.
* Ov_ForEachParentNMEx()::        Iterate over all parent objects in an n:m association and dynamically cast to a given parent class.
* Ov_Link()::                     Link parent and child object, no placement hint (1:n or n:m association).
* Ov_LinkPlaced()::               Link parent and child object with given child placement hint (1:n association).
* Ov_LinkRelativePlaced()::       Link parent and child object with given relative child placement hint (1:n association).
* Ov_Unlink()::                   Unlink parent and child object (1:n or n:m association).
* Ov_LinkNM()::                   Link parent and child object, no placement hint (1:n or n:m association).
* Ov_LinkPlacedNM()::             Link parent and child object with given child placement hint (n:m association).
* Ov_LinkRelativePlacedNM()::     Link parent and child object with given relative placement hints (n:m association).
* Ov_UnlinkNM()::                 Unlink parent and child object (1:n or n:m association).
* Ov_PtrUpCast()::                Upcast to a pointer of a given base class.
* Ov_StaticPtrCast()::            Static cast to a pointer of a given class.
* Ov_CanCastTo()::                Test if it is allowed to cast to a given class.
* Ov_DynamicPtrCast()::           Dynamic cast to a pointer of a given class.
* Ov_CreateObject()::             Create an object of a given class.
* Ov_DeleteObject()::             Delete an object.
* Ov_GetStaticInstPtr()::         Get a pointer to the static part of an object.
* Ov_GetPartPtr()::               Get a pointer to a part object.
* Ov_GetClassPtr()::              Get pointer to the class object of an instance.
* Ov_GetVTablePtr()::             Get the vtable pointer to an object of a given class.
* Ov_GetBaseclassVTablePtr()::    Get the vtable pointer of the direct base class of an object of a given class.
* Ov_IsVariable()::               Test, if a variable definition object defines a variable with a given name.
* Ov_SetStaticVectorValue()::     Set the value of a static vector variable.
* Ov_SetDynamicVectorValue()::    Set the value of a dynamic vector variable.
* Ov_SetDynamicVectorLength()::   Set the vector length of a dynamic vector variable.
* Ov_CompareVectorValues()::      Compare two vector variable values.
* Ov_TimeToDouble()::             Convert a time (span) into a double variable.
* Ov_DoubleToTime()::             Convert a double into a time (span) variable.
* Ov_DbAlloc()::                  Allocate memory in the database.
* Ov_DbMalloc()::                 Allocate memory in the database.
* Ov_DbFree()::                   Free memory allocated in the database.
* Ov_MemStackAlloc()::            Allocate memory on the stack memory.
* Ov_HeapAlloc()::                Allocate memory on the heap.
* Ov_HeapMalloc()::               Allocate memory on the heap.
* Ov_HeapRealloc()::              Reallocate memory on the heap.
* Ov_HeapFree()::                 Free memory allocated on the heap.
* Ov_HeapStrdup()::               Duplicate a string on the heap.
@end menu

@c	--------------------------------

@node Ov_ParentPtrUpCast(), Ov_ChildPtrUpCast(), Useful macros, Useful macros
@section Upcast of an instance pointer of the parent class

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_ParentPtrUpCast(assoc, pparent);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_ChildPtrUpCast(), Ov_GetFirstChild(), Ov_ParentPtrUpCast(), Useful macros
@section Upcast of an instance pointer of the child class

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_ChildPtrUpCast(assoc, pchild);}

@strong{Parameters}

@table @code
@item assoc

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetFirstChild(), Ov_GetLastChild(), Ov_ChildPtrUpCast(), Useful macros
@section Get first child in a 1:n association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pchild = Ov_GetFirstChild(assoc, pparent);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetLastChild(), Ov_GetNextChild(), Ov_GetFirstChild(), Useful macros
@section Get last child in a 1:n association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pchild = Ov_GetLastChild(assoc, pparent);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetNextChild(), Ov_GetPreviousChild(), Ov_GetLastChild(), Useful macros
@section Get next child in a 1:n association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pchild = Ov_GetNextChild(assoc, pchild);}

@strong{Parameters}

@table @code
@item assoc

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetPreviousChild(), Ov_GetParent(), Ov_GetNextChild(), Useful macros
@section Get previous child a 1:n association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pchild = Ov_GetPreviousChild(assoc, pchild);}

@strong{Parameters}

@table @code
@item assoc

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetParent(), Ov_ForEachChild(), Ov_GetPreviousChild(), Useful macros
@section Get parent in a 1:n association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pparent = Ov_GetParent(assoc, pchild);}

@strong{Parameters}

@table @code
@item assoc

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_ForEachChild(), Ov_ForEachChildEx(), Ov_GetParent(), Useful macros
@section Iterate over all child objects in a 1:n association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{Ov_ForEachChild(assoc, pparent, pchild);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_ForEachChildEx(), Ov_SearchChild(), Ov_ForEachChild(), Useful macros
@section Iterate over all child objects in a 1:n association and dynamically cast to a given child class

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{Ov_ForEachChildEx(assoc, pparent, pchild, childclass);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@item pchild

@item childclass

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_SearchChild(), Ov_SearchChildEx(), Ov_ForEachChildEx(), Useful macros
@section Search a child with given identifier in a 1:n association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pchild = Ov_SearchChild(assoc, pparent, ident);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@item ident

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_SearchChildEx(), Ov_DefineIteratorNM(), Ov_SearchChild(), Useful macros
@section Search a child with given identifier and cast to child class in a 1:n association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pchild = Ov_SearchChildEx(assoc, pparent, ident, childclass);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@item ident

@item childclass

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_DefineIteratorNM(), Ov_GetFirstChildNM(), Ov_SearchChildEx(), Useful macros
@section Define an iterator for iterating over n:m associations

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_DefineIteratorNM(assoc, pit);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetFirstChildNM(), Ov_GetLastChildNM(), Ov_DefineIteratorNM(), Useful macros
@section Get first child in an n:m association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pchild = Ov_GetFirstChildNM(assoc, pit, pparent);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetLastChildNM(), Ov_GetNextChildNM(), Ov_GetFirstChildNM(), Useful macros
@section Get last child in an n:m association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pchild = Ov_GetLastChildNM(assoc, pit, pparent);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetNextChildNM(), Ov_GetPreviousChildNM(), Ov_GetLastChildNM(), Useful macros
@section Get next child in an n:m association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pchild = Ov_GetNextChildNM(assoc, pit);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetPreviousChildNM(), Ov_GetFirstParentNM(), Ov_GetNextChildNM(), Useful macros
@section Get previous child in an n:m association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pchild = Ov_GetPreviousChildNM(assoc, pit);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetFirstParentNM(), Ov_GetLastParentNM(), Ov_GetPreviousChildNM(), Useful macros
@section Get first parent in an n:m association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pparent = Ov_GetFirstParentNM(assoc, pit, pchild);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetLastParentNM(), Ov_GetNextParentNM(), Ov_GetFirstParentNM(), Useful macros
@section Get last parent in an n:m association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pparent = Ov_GetLastParentNM(assoc, pit, pchild);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetNextParentNM(), Ov_GetPreviousParentNM(), Ov_GetLastParentNM(), Useful macros
@section Get next parent in an n:m association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pparent = Ov_GetNextParentNM(assoc, pit);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetPreviousParentNM(), Ov_ForEachChildNM(), Ov_GetNextParentNM(), Useful macros
@section Get previous parent in an n:m association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{pparent = Ov_GetPreviousParentNM(assoc, pit);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_ForEachChildNM(), Ov_ForEachChildNMEx(), Ov_GetPreviousParentNM(), Useful macros
@section Iterate over all child objects in an n:m association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{Ov_ForEachChildNM(assoc, pit, pparent, pchild);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@item pparent

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_ForEachChildNMEx(), Ov_ForEachParentNM(), Ov_ForEachChildNM(), Useful macros
@section Iterate over all child objects in an n:m association and dynamically cast to a given child class

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{Ov_ForEachChildNMEx(assoc, pit, pparent, pchild, childclass);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@item pparent

@item pchild

@item childclass

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_ForEachParentNM(), Ov_ForEachParentNMEx(), Ov_ForEachChildNMEx(), Useful macros
@section Iterate over all parent objects in an n:m association

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{Ov_ForEachParentNM(assoc, pit, pchild, pparent);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@item pchild

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_ForEachParentNMEx(), Ov_Link(), Ov_ForEachParentNM(), Useful macros
@section Iterate over all parent objects in an n:m association and dynamically cast to a given parent class

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{Ov_ForEachParentNMEx(assoc, pit, pchild, pparent, parentclass);}

@strong{Parameters}

@table @code
@item assoc

@item pit

@item pchild

@item pparent

@item parentclass

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Link(), Ov_LinkPlaced(), Ov_ForEachParentNMEx(), Useful macros
@section Link parent and child object (1:n or n:m association)

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_Link(assoc, pparent, pchild);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_LinkPlaced(), Ov_LinkRelativePlaced(), Ov_Link(), Useful macros
@section Link parent and child object with given child placement hint (1:n association)

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_LinkPlaced(assoc, pparent, pchild, childhint);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@item pchild

@item childhint

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_LinkRelativePlaced(), Ov_Unlink(), Ov_LinkPlaced(), Useful macros
@section Link parent and child object with given relative child placement hint (1:n association)

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_LinkRelativePlaced(assoc, pparent, pchild, childhint, prelchild);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@item pchild

@item childhint

@item prelchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Unlink(), Ov_LinkNM(), Ov_LinkRelativePlaced(), Useful macros
@section Unlink parent and child object (1:n or n:m association)

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{Ov_Unlink(assoc, pparent, pchild);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_LinkNM(), Ov_LinkPlacedNM(), Ov_Unlink(), Useful macros
@section Link parent and child object (1:n or n:m association)

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_LinkNM(assoc, pparent, pchild);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_LinkPlacedNM(), Ov_LinkRelativePlacedNM(), Ov_LinkNM(), Useful macros
@section Link parent and child object with given child placement hint (n:m association)

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_LinkPlacedNM(assoc, pparent, pchild, parenthint, childhint);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@item pchild

@item parenthint

@item childhint

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_LinkRelativePlacedNM(), Ov_UnlinkNM(), Ov_LinkPlacedNM(), Useful macros
@section Link parent and child object with given relative placement hints (n:m association)

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_LinkRelativePlacedNM(assoc, pparent, pchild, parenthint, prelparent, childhint, prelchild);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@item pchild

@item parenthint

@item prelparent

@item childhint

@item prelchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_UnlinkNM(), Ov_PtrUpCast(), Ov_LinkRelativePlacedNM(), Useful macros
@section Unlink parent and child object (1:n or n:m association)

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{Ov_UnlinkNM(assoc, pparent, pchild);}

@strong{Parameters}

@table @code
@item assoc

@item pparent

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_PtrUpCast(), Ov_StaticPtrCast(), Ov_UnlinkNM(), Useful macros
@section Upcast to a pointer of a given base class

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_PtrUpCast(class, pobj);}

@strong{Parameters}

@table @code
@item class

@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_StaticPtrCast(), Ov_CanCastTo(), Ov_PtrUpCast(), Useful macros
@section Static cast to a pointer of a given class

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_StaticPtrCast(class, pobj);}

@strong{Parameters}

@table @code
@item class

@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_CanCastTo(), Ov_DynamicPtrCast(), Ov_StaticPtrCast(), Useful macros
@section Test if it is allowed to cast to a given class

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_CanCastTo(class, pobj);}

@strong{Parameters}

@table @code
@item class

@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_DynamicPtrCast(), Ov_CreateObject(), Ov_CanCastTo(), Useful macros
@section Dynamic cast to a pointer of a given class

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_DynamicPtrCast(class, pobj);}

@strong{Parameters}

@table @code
@item class

@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_CreateObject(), Ov_DeleteObject(), Ov_DynamicPtrCast(), Useful macros
@section Create an object of a given class

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_CreateObject(class, pobj, pparent, ident);}

@strong{Parameters}

@table @code
@item class

@item pobj

@item pparent

@item ident

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_DeleteObject(), Ov_GetStaticInstPtr(), Ov_CreateObject(), Useful macros
@section Delete an object

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{Ov_DeleteObject(pobj);}

@strong{Parameters}

@table @code
@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetStaticInstPtr(), Ov_GetPartPtr(), Ov_DeleteObject(), Useful macros
@section Get a pointer to the static part of an object

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_GetStaticInstPtr(class, pobj);}

@strong{Parameters}

@table @code
@item class

@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetPartPtr(), Ov_GetClassPtr(), Ov_GetStaticInstPtr(), Useful macros
@section Get a pointer to a part object

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_GetPartPtr(part, pobj);}

@strong{Parameters}

@table @code
@item part

@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetClassPtr(), Ov_GetVTablePtr(), Ov_GetPartPtr(), Useful macros
@section Get pointer to the class object of an instance

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_GetClassPtr(pobj);}

@strong{Parameters}

@table @code
@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetVTablePtr(), Ov_GetBaseclassVTablePtr(), Ov_GetClassPtr(), Useful macros
@section Get the vtable pointer to an object of a given class

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_GetVTablePtr(class, pvtable, pobj);}

@strong{Parameters}

@table @code
@item class

@item pvtable

@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_GetBaseclassVTablePtr(), Ov_IsVariable(), Ov_GetVTablePtr(), Useful macros
@section Get the vtable pointer of the direct base class of an object of a given class

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_GetBaseclassVTablePtr(class, pobj);}

@strong{Parameters}

@table @code
@item class

@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_IsVariable(), Ov_SetStaticVectorValue(), Ov_GetBaseclassVTablePtr(), Useful macros
@section Test, if a variable definition object defines a variable with a given name

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_IsVariable(class, name, pvar);}

@strong{Parameters}

@table @code
@item class

@item name

@item pvar

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_SetStaticVectorValue(), Ov_SetDynamicVectorValue(), Ov_IsVariable(), Useful macros
@section Set the value of a static vector variable

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_SetStaticVectorValue(pvector, pvalue, veclen, type);}

@strong{Parameters}

@table @code
@item pvector

@item pvalue

@item veclen

@item type

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_SetDynamicVectorValue(), Ov_SetDynamicVectorLength(), Ov_SetStaticVectorValue(), Useful macros
@section Set the value of a dynamic vector variable

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_SetDynamicVectorValue(pvector, pvalue, veclen, type);}

@strong{Parameters}

@table @code
@item pvector

@item pvalue

@item veclen

@item type

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_SetDynamicVectorLength(), Ov_CompareVectorValues(), Ov_SetDynamicVectorValue(), Useful macros
@section Set the vector length of a dynamic vector variable

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_SetDynamicVectorLength(pvector, veclen, type);}

@strong{Parameters}

@table @code
@item pvector

@item veclen

@item type

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_CompareVectorValues(), Ov_TimeToDouble(), Ov_SetDynamicVectorLength(), Useful macros
@section Compare two vector variable values

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_CompareVectorValues(pvalue1, pvalue2, veclen, type);}

@strong{Parameters}

@table @code
@item pvalue1

@item pvalue2

@item veclen

@item type

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_TimeToDouble(), Ov_DoubleToTime(), Ov_CompareVectorValues(), Useful macros
@section Convert a time (span) into a double variable

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_TimeToDouble(time, dbl);}

@strong{Parameters}

@table @code
@item time

@item dbl

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_DoubleToTime(), Ov_DbAlloc(), Ov_TimeToDouble(), Useful macros
@section Convert a double into a time (span) variable

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_DoubleToTime(dbl, time);}

@strong{Parameters}

@table @code
@item dbl

@item time

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_DbAlloc(), Ov_DbMalloc(), Ov_DoubleToTime(), Useful macros
@section Allocate memory in the database

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_DbAlloc(type);}

@strong{Parameters}

@table @code
@item type

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_DbMalloc(), Ov_DbFree(), Ov_DbAlloc(), Useful macros
@section Allocate memory in the database

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_DbMalloc(size);}

@strong{Parameters}

@table @code
@item size

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_DbFree(), Ov_MemStackAlloc(), Ov_DbMalloc(), Useful macros
@section Free memory allocated in the database

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{Ov_DbFree(ptr);}

@strong{Parameters}

@table @code
@item ptr

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_MemStackAlloc(), Ov_HeapAlloc(), Ov_DbFree(), Useful macros
@section Allocate memory on the stack memory

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_MemStackAlloc(type);}

@strong{Parameters}

@table @code
@item type

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_HeapAlloc(), Ov_HeapMalloc(), Ov_MemStackAlloc(), Useful macros
@section Allocate memory on the heap

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_HeapAlloc(type);}

@strong{Parameters}

@table @code
@item type

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_HeapMalloc(), Ov_HeapRealloc(), Ov_HeapAlloc(), Useful macros
@section Allocate memory on the heap

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_HeapMalloc(size);}

@strong{Parameters}

@table @code
@item size

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_HeapRealloc(), Ov_HeapFree(), Ov_HeapMalloc(), Useful macros
@section Reallocate memory on the heap

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_HeapRealloc(ptr, size);}

@strong{Parameters}

@table @code
@item ptr

@item size

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_HeapFree(), Ov_HeapStrdup(), Ov_HeapRealloc(), Useful macros
@section Free memory allocated on the heap

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{Ov_HeapFree(ptr);}

@strong{Parameters}

@table @code
@item ptr

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_HeapStrdup(), , Ov_HeapFree(), Useful macros
@section Duplicate a string on the heap

@strong{Header file}

@code{#include "libov/ov_macros.h"}

@strong{Macro usage}

@code{ = Ov_HeapStrdup(ptr);}

@strong{Parameters}

@table @code
@item ptr

@end table

@strong{Return value}

@strong{Remarks}

@c	---------------------
@c	Fundamental datatypes
@c	---------------------

@node Fundamental datatypes, Association, Useful macros, Top
@chapter Fundamental datatypes used in the library

Datatypes of object variables supported by the ACPLT/OV modeling language:
@menu
* OV_BOOL::                Bool value.
* OV_INT::                 Signed integer value.
* OV_UINT::                Unsigned integer value.
* OV_SINGLE::              Single precision floating point value.
* OV_DOUBLE::              Double precision floating point value.
* OV_STRING::              String value.
* OV_TIME::                Time or date value.
* OV_TIME_SPAN::           Time span value.
@end menu

Datatypes associated with objects:
@menu
* OV_OBJ_STATE::           Macro state of an object.
@end menu

Datatypes associated with variables of an object:
@menu
* OV_VAR_TYPE::            Type of a variable.
* OV_VAR_VALUE::           Value of a variable.
* OV_STATE::               State of a variable.
* OV_VAR_CURRENT_PROPS::   Current properties of a variable.
@end menu

Datatypes associated with functions or methods of an object:
@menu
* OV_RESULT::              Result of a function call.
@end menu

Datatypes associated with links of an object:
@menu
* OV_ASSOC_TYPE::          Type of an association.
* OV_PLACEMENT_HINT::      Placement hint used with links.
@end menu

Datatypes associated with access rights and authentification/verification:
@menu
* OV_ACCESS::              Access rights of an object.
* OV_TICKET_TYPE::         Type of an A/V-ticket.
* OV_TICKET_VTBL::         Virtual function table associated with a ticket.
* OV_TICKET::              A/V-ticket.
@end menu

Generic datatypes for different purposes:
@menu
* OV_BYTE::                Generic byte value.
* OV_ENUM::                Generic enumeration value.
* OV_POINTER::             Generic pointer value.
@end menu

Vector datatypes:

@menu
* OV_BOOL_VEC::            Dynamic bool value vector.
* OV_INT_VEC::             Dynamic signed integer value vector.
* OV_UINT_VEC::            Dynamic unsigned integer value vector.
* OV_SINGLE_VEC::          Dynamic single precision floating point value vector.
* OV_DOUBLE_VEC::          Dynamic double precision floating point value vector.
* OV_STRING_VEC::          Dynamic string value vector.
* OV_TIME_VEC::            Dynamic time/date value vector.
* OV_TIME_SPAN_VEC::       Dynamic time span value vector.
* OV_GENERIC_VEC::         Generic dynamic value vector (internal use).
@end menu

PV (Process Value) datatypes:

@menu
* OV_BOOL_PV::             Boolean process value.
* OV_INT_PV::              Integer process value.
* OV_SINGLE_PV::           Single precision floating point process value.
@end menu

Datatypes holding properties of the ACPLT/OV metamodel:

@menu
* OV_VAR_PROPS::           Variable properties.
* OV_CLASS_PROPS::         Class properties.
* OV_ASSOC_PROPS::         Association properties.
* OV_OP_PROPS::            Operation properties.
@end menu

Datatypes associated with ACPLT/KS histories:

@menu
* OV_TIME_TYPE::           Time types for use with ACPLT/KS histories.
* OV_HSEL_TYPE::           Selector types for use with ACPLT/KS histories.
* OV_HIST_TYPE::           History types for use with ACPLT/KS histories.
* OV_INTERPOLATION_MODE::  Interpolation modes for use with ACPLT/KS histories.
@end menu

Datatypes associated with logfiles:

@menu
* OV_MSG_TYPE::            Type of a logfile message.
@end menu

@c	--------------------------------

@node OV_BOOL, OV_INT, Fundamental datatypes, Fundamental datatypes
@section Bool value

A bool value may have one out of two possible values, @code{TRUE} or
@code{FALSE}.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@code{typedef bool_t OV_BOOL;}

@strong{Remarks}

The datatype @code{bool_t} is declared in the Sun ONC/RPC header
@code{rpc/types.h} and falls back on the @code{int} datatype. 

The reason for using this datatype in ACPLT/OV is that using this declaration 
we do not need any conversion when encoding/decoding a bool value in ACPLT/OV 
into/from an XDR stream.

@c	--------------------------------

@node OV_INT, OV_UINT, OV_BOOL, Fundamental datatypes
@section Signed integer value

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@code{typedef long OV_INT;}

@c	--------------------------------

@node OV_UINT, OV_SINGLE, OV_INT, Fundamental datatypes
@section Unsigned integer value

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@code{typedef u_long OV_UINT;}

@strong{Remarks}

The datatype @code{u_long} is declared in the Sun ONC/RPC header
@code{rpc/types.h} and falls back on the @code{unsigned long} datatype. 

The reason for using this datatype in ACPLT/OV is that using this declaration 
we do not need any conversion when encoding/decoding an unsigned integer value 
in ACPLT/OV into/from an XDR stream.

@c	--------------------------------

@node OV_SINGLE, OV_DOUBLE, OV_UINT, Fundamental datatypes
@section Single precision floating point value

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@code{typedef single OV_SINGLE;}

@c	--------------------------------

@node OV_DOUBLE, OV_STRING, OV_SINGLE, Fundamental datatypes
@section Double precision floating point value

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@code{typedef double OV_DOUBLE;}

@c	--------------------------------

@node OV_STRING, OV_TIME, OV_DOUBLE, Fundamental datatypes
@section String value

A string value is a pointer a @code{NULL}-terminated @code{char} array.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@code{typedef char* OV_STRING;}

@strong{Remarks}

@code{OV_STRING} does not contain the actual string but a pointer to a 
@code{NULL}-terminated @code{char} array. This means that you must pay
careful attention to the question who the owner of the string is.

If the string belongs to the instance of an ACPLT/OV class, the instance
is the owner of the string and the string must @strong{always} be stored
in the database unless the string pointer is @code{NULL}. The ACPLT/OV 
library provides the functions @code{ov_string_setvalue()} and 
@code{ov_string_setvecvalue()} which take care of setting such string values
of instances for you. Do @strong{not} use this function for string values
that do not belong to instances of ACPLT/OV classes!

In all other cases the ownership of the string must to specially indicated.
ACPLT/OV Object Management Library functions returning string values, such 
as @code{ov_path_getcanonicalpath()}, allocated the string on the memory 
stack. If you call such a function, you must call the function 
@code{ov_memstack_lock()} before call the desired function and call the 
function @code{ov_memstack_unlock()} when you do not need the string anymore
(but always in the same routine). This way strings may be located persistently
in the database or temporary on the memory stack and you will not have
to care too much about the ownership.

@c	--------------------------------

@node OV_TIME, OV_TIME_SPAN, OV_STRING, Fundamental datatypes
@section Time or date value

A time or date value is represented by a structure which contains the time 
in seconds and microseconds elapsed since January 1, 1970, 00:00:00.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_UINT secs;  /* seconds */
    OV_UINT usecs; /* microseconds */
@}   OV_TIME;}
@end format

@strong{Remarks}

The @code{usecs} member must always contain a value between @code{0}
and @code{999999}.

@c	--------------------------------

@node OV_TIME_SPAN, OV_OBJ_STATE, OV_TIME, Fundamental datatypes
@section Time span value

A time span is a time difference (duration) and represented by a structure 
which contains the time span in seconds and microseconds.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_INT secs;  /* seconds */
    OV_INT usecs; /* microseconds */
@}   OV_TIME_SPAN;}
@end format

@strong{Remarks}

The @code{usecs} member must always contain a value between @code{-999999}
and @code{999999}. If both members of the structure contain a value not
equal to @code{0}, both members must have the same sign.

@c	--------------------------------

@node OV_OBJ_STATE, OV_VAR_TYPE, OV_TIME_SPAN, Fundamental datatypes
@section Macro state of an object

@code{OV_OBJ_STATE} is an enumeration value defining the macro state of
an object.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_OS_NONE    0x00000000 /* object is not yet initialized */
#define OV_OS_INIT    0x00000001 /* object is initialized */
#define OV_OS_STARTED 0x00000002 /* object is started up */
#define OV_OS_ACTIVE  0x00000004 /* object is active */

typedef OV_ENUM OV_OBJ_STATE;}
@end format

@c	--------------------------------

@node OV_VAR_TYPE, OV_VAR_VALUE, OV_OBJ_STATE, Fundamental datatypes
@section Type of a variable

@code{OV_VAR_VALUE} is an enumeration value defining the datatype of an 
ACPLT/OV variable.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_VT_BOOL          KS_VT_BOOL          /* bool */
#define OV_VT_INT           KS_VT_INT           /* signed integer */
#define OV_VT_UINT          KS_VT_UINT          /* unsigned integer */
#define OV_VT_SINGLE        KS_VT_SINGLE        /* single */
#define OV_VT_DOUBLE        KS_VT_DOUBLE        /* double */
#define OV_VT_STRING        KS_VT_STRING        /* string */
#define OV_VT_TIME          KS_VT_TIME          /* time */
#define OV_VT_TIME_SPAN     KS_VT_TIME_SPAN     /* time span */

#define OV_VT_BOOL_VEC      KS_VT_BOOL_VEC      /* bool vector */
#define OV_VT_INT_VEC       KS_VT_INT_VEC       /* signed integer vector */
#define OV_VT_UINT_VEC      KS_VT_UINT_VEC      /* unsigned integer vector */
#define OV_VT_SINGLE_VEC    KS_VT_SINGLE_VEC    /* single vector */
#define OV_VT_DOUBLE_VEC    KS_VT_DOUBLE_VEC    /* double vector */
#define OV_VT_STRING_VEC    KS_VT_STRING_VEC    /* string vector */
#define OV_VT_TIME_VEC      KS_VT_TIME_VEC      /* time vector */
#define OV_VT_TIME_SPAN_VEC KS_VT_TIME_SPAN_VEC /* time span vector */

#define OV_VT_STRUCT        KS_VT_STRUCT        /* structure */

#define OV_VT_VOID          KS_VT_VOID          /* void */
#define OV_VT_BYTE_VEC      KS_VT_BYTE_VEC      /* opaque byte vector */

typedef OV_ENUM OV_VAR_TYPE;}
@end format

@strong{Remarks}

Note, that the enumeration values are identical to the corresponding ACPLT/KS
values of the datatype @code{KS_VAR_TYPE}.

@c	--------------------------------

@node OV_VAR_VALUE, OV_STATE, OV_VAR_TYPE, Fundamental datatypes
@section Value of a variable

The value of a variable is a structure containing the datatype, the vector
length and the actual value of a variable.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_VAR_TYPE vartype;
    OV_UINT     veclen;
    union @{
        OV_BOOL      val_bool;           /* if vartype == OV_VT_BOOL */
        OV_INT       val_int;            /* if vartype == OV_VT_INT */
        OV_UINT      val_uint;           /* if vartype == OV_VT_UINT */
        OV_SINGLE    val_single;         /* if vartype == OV_VT_SINGLE */
        OV_DOUBLE    val_double;         /* if vartype == OV_VT_DOUBLE */
        OV_STRING    val_string;         /* if vartype == OV_VT_STRING */
        OV_TIME      val_time;           /* if vartype == OV_VT_TIME */
        OV_TIME_SPAN val_time_span;      /* if vartype == OV_VT_TIME_SPAN */
        OV_BOOL      *val_bool_vec;      /* if vartype == OV_VT_BOOL_VEC */
        OV_INT       *val_int_vec;       /* if vartype == OV_VT_INT_VEC */
        OV_UINT      *val_uint_vec;      /* if vartype == OV_VT_UINT_VEC */
        OV_SINGLE    *val_single_vec;    /* if vartype == OV_VT_SINGLE_VEC */
        OV_DOUBLE    *val_double_vec;    /* if vartype == OV_VT_DOUBLE_VEC */
        OV_STRING    *val_string_vec;    /* if vartype == OV_VT_STRING_VEC */
        OV_TIME      *val_time_vec;      /* if vartype == OV_VT_TIME_VEC */
        OV_TIME_SPAN *val_time_span_vec; /* if vartype == OV_VT_TIME_SPAN_VEC */
        char         *val_byte_vec;      /* if vartype == OV_VT_BYTE_VEC */
    @}   valueunion;
@}   OV_VAR_VALUE;}
@end format

@c	--------------------------------

@node OV_STATE, OV_VAR_CURRENT_PROPS, OV_VAR_VALUE, Fundamental datatypes
@section State of a variable

@code{OV_STATE} is an enumeration value defining the state of an 
ACPLT/OV variable.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_ST_NOTSUPPORTED KS_ST_NOTSUPPORTED /* no state available */
#define OV_ST_UNKNOWN      KS_ST_UNKNOWN      /* state unknown at this time */
#define OV_ST_BAD          KS_ST_BAD          /* information is bad */
#define OV_ST_QUESTIONABLE KS_ST_QUESTIONABLE /* information is questionable */
#define OV_ST_GOOD         KS_ST_GOOD         /* information is good */

typedef OV_ENUM OV_STATE;}
@end format

@strong{Remarks}

Note, that the enumeration values are identical to the corresponding ACPLT/KS
values of the datatype @code{KS_STATE}.

@c	--------------------------------

@node OV_VAR_CURRENT_PROPS, OV_RESULT, OV_STATE, Fundamental datatypes
@section Current properties of a variable

The current properties of a variable are a structure containing the value, the
state and the timestamp of a variable.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_VAR_VALUE value;
    OV_STATE     state;
    OV_TIME      time;
@}   OV_VAR_CURRENT_PROPS;}
@end format

@strong{Remarks}

Compare the definition of the current properties of a variable in ACPLT/KS.

@c	--------------------------------

@node OV_RESULT, OV_ASSOC_TYPE, OV_VAR_CURRENT_PROPS, Fundamental datatypes
@section Result of a function call

@code{OV_RESULT} is an enumeration value defining the result of a function 
call.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_ERR_OK                KS_ERR_OK             /* ok, no error */
#define OV_ERR_GENERIC           KS_ERR_GENERIC        /* generic error */
#define OV_ERR_TARGETGENERIC     KS_ERR_TARGETGENERIC  /* generic error in target */
#define OV_ERR_BADAUTH           KS_ERR_BADAUTH        /* bad authentification */
#define OV_ERR_UNKNOWNAUTH       KS_ERR_UNKNOWNAUTH    /* unknown authentification */
#define OV_ERR_NOTIMPLEMENTED    KS_ERR_NOTIMPLEMENTED /* not implemented */
#define OV_ERR_BADPARAM          KS_ERR_BADPARAM       /* bad parameter */
#define OV_ERR_BADOBJTYPE        KS_ERR_BADOBJTYPE     /* bad object type */

#define OV_ERR_BADNAME           KS_ERR_BADNAME        /* bad name */
#define OV_ERR_BADPATH           KS_ERR_BADPATH        /* bad path */
#define OV_ERR_BADMASK           KS_ERR_BADMASK        /* bad mask */
#define OV_ERR_NOACCESS          KS_ERR_NOACCESS       /* no access */
#define OV_ERR_BADTYPE           KS_ERR_BADTYPE        /* bad type */
#define OV_ERR_BADVALUE          KS_ERR_BADVALUE       /* bad value */

#define OV_ERR_BADFACTORY        KS_ERR_BADFACTORY     /* bad factory */
#define OV_ERR_ALREADYEXISTS     KS_ERR_ALREADYEXISTS  /* object already exists */
#define OV_ERR_BADINITPARAM      KS_ERR_BADINITPARAM   /* bad initialization parameter */
#define OV_ERR_BADPLACEMENT      KS_ERR_BADPLACEMENT   /* bad placement */

#define OV_ERR_CANTCREATEFILE    0x00010000            /* can't create file */
#define OV_ERR_CANTOPENFILE      0x00010001            /* can't open file */
#define OV_ERR_CANTLOCKFILE      0x00010002            /* can't lock file */
#define OV_ERR_CANTREADFROMFILE  0x00010003            /* can't read from file */
#define OV_ERR_CANTWRITETOFILE   0x00010004            /* can't write to file */
#define OV_ERR_CANTMAPFILE       0x00010005            /* can't map file to memory */
#define OV_ERR_BADDATABASE       0x00010006            /* bad database */

#define OV_ERR_CANTOPENLIBRARY   0x00010010            /* can't open library */

#define OV_ERR_LIBDEFMISMATCH    0x00010020            /* library def. mismatch */
#define OV_ERR_STRUCTDEFMISMATCH 0x00010021            /* structure def. mismatch */
#define OV_ERR_CLASSDEFMISMATCH  0x00010022            /* class def. mismatch */
#define OV_ERR_ASSOCDEFMISMATCH  0x00010023            /* association def. mismatch */
#define OV_ERR_VARDEFMISMATCH    0x00010024            /* variable def. mismatch */
#define OV_ERR_PARTDEFMISMATCH   0x00010025            /* part def. mismatch */
#define OV_ERR_OPDEFMISMATCH     0x00010026            /* operation def. mismatch */
#define OV_ERR_UNKNOWNSTRUCTDEF  0x00010027            /* unknown structure def. */
#define OV_ERR_UNKNOWNCLASSDEF   0x00010028            /* unknown class def. */
#define OV_ERR_UNKNOWNASSOCDEF   0x00010029            /* unknown association def. */

#define OV_ERR_DBOUTOFMEMORY     0x00010030            /* database is out of memory */
#define OV_ERR_HEAPOUTOFMEMORY   0x00010031            /* heap is out of memory */

typedef OV_ENUM OV_RESULT;}
@end format

@strong{Remarks}

Note, that the some enumeration values are identical to the corresponding ACPLT/KS
values of the datatype @code{KS_RESULT}.

@c	--------------------------------

@node OV_ASSOC_TYPE, OV_PLACEMENT_HINT, OV_RESULT, Fundamental datatypes
@section Type of an association

@code{OV_STATE} is an enumeration value defining the type of an 
ACPLT/OV association.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_AT_ORDERED_LIST 0x00000001 /* ordered list */

typedef OV_ENUM OV_ASSOC_TYPE;}
@end format

@c	--------------------------------

@node OV_PLACEMENT_HINT, OV_ACCESS, OV_ASSOC_TYPE, Fundamental datatypes
@section Placement hint used with links

@code{OV_PLACEMENT_HINT} is an enumeration value defining a hint for the
placement of a new member in a link when creating a new link between
to objects.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_PMH_DEFAULT KS_PMH_DEFAULT /* default placement */
#define OV_PMH_BEGIN   KS_PMH_BEGIN   /* at the beginning */
#define OV_PMH_END     KS_PMH_END     /* at the end */
#define OV_PMH_BEFORE  KS_PMH_BEFORE  /* before a given object */
#define OV_PMH_AFTER   KS_PMH_AFTER   /* after a given object */

typedef OV_ENUM OV_PLACEMENT_HINT;}
@end format

@strong{Remarks}

Note, that the enumeration values are identical to the corresponding ACPLT/KS
values of the datatype @code{KS_PLACEMENT_HINT}.

@c	--------------------------------

@node OV_ACCESS, OV_TICKET_TYPE, OV_PLACEMENT_HINT, Fundamental datatypes
@section Access rights of an object

@code{OV_ACCESS} is an enumeration value defining the access rights of an 
ACPLT/OV object or any of its parts. The access rights also indicate if an
object or part is a part of another object or part.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_AC_NONE         KS_AC_NONE         /* no access at all, element is not visible */
#define OV_AC_READ         KS_AC_READ         /* read access */
#define OV_AC_WRITE        KS_AC_WRITE        /* write access */
#define OV_AC_READWRITE    KS_AC_READWRITE    /* both read and write access */
#define OV_AC_INSTANTIABLE KS_AC_INSTANTIABLE /* object can act as a factory */
#define OV_AC_PART         KS_AC_PART         /* object is part of another object */
#define OV_AC_DELETEABLE   0x00010000         /* object can be deleted */
#define OV_AC_LINKABLE     0x00010010         /* parent/child can be linked */
#define OV_AC_UNLINKABLE   0x00010011         /* parent/child can be unlinked */

typedef OV_ENUM OV_ACCESS;}
@end format

@strong{Remarks}

Note, that the some enumeration values are identical to the corresponding ACPLT/KS
values of the datatype @code{KS_ACCESS}.

@c	--------------------------------

@node OV_TICKET_TYPE, OV_TICKET_VTBL, OV_ACCESS, Fundamental datatypes
@section Type of an A/V-ticket

@code{OV_TICKET_TYPE} is an enumeration value defining the type of an 
ACPLT/KS authentification/verification ticket (compare ACPLT/KS documentation).

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_TT_NONE   KS_AUTH_NONE   /* no ticket */
#define OV_TT_SIMPLE KS_AUTH_SIMPLE /* a simple ticket */

typedef OV_ENUM OV_TICKET_TYPE;}
@end format

@strong{Remarks}

Note, that the enumeration values are identical to the corresponding ACPLT/KS
values of the datatype @code{KS_AUTH_TYPE}.

@c	--------------------------------

@node OV_TICKET_VTBL, OV_TICKET, OV_TICKET_TYPE, Fundamental datatypes
@section Virtual function table associated with a ticket

@code{OV_TICKET_VTBL} is a virtual function table associated with an
ACPLT/KS authentification/verification ticket of a given ticket type
(compare ACPLT/KS documentation).

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_TICKET *(* createticket)(XDR *xdr, OV_TICKET_TYPE type);
    void      (* deleteticket)(OV_TICKET *pticket);
    OV_BOOL   (* encodereply)(XDR *xdr, OV_TICKET *pticket);
    OV_ACCESS (* getaccess)(const OV_TICKET *pticket);
@}   OV_TICKET_VTBL;}
@end format

@strong{Remarks}

Please see the file @code{ov_server.c} for an example how to use virtual
function tables of ACPLT/KS tickets in an ACPLT/OV server.

@c	--------------------------------

@node OV_TICKET, OV_BYTE, OV_TICKET_VTBL, Fundamental datatypes
@section A/V-ticket

An A/V-ticket (authentification/verification ticket) is a structure containing
the type of the ticket and, depending on this type, further parameters.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    struct OV_TICKET_VTBL *vtbl; /* not used when acting as a ACPLT/KS client */
    OV_TICKET_TYPE        type;
    union @{
        struct @{
            OV_STRING     id;    /* only, if tickettype == OV_TT_SIMPLE */
        @}   simpleticket;
    @}   ticketunion;
@}   OV_TICKET;}
@end format

@strong{Remarks}

Compare the definition of A/V-tickets in ACPLT/KS.

@c	--------------------------------

@node OV_BYTE, OV_ENUM, OV_TICKET, Fundamental datatypes
@section Generic byte value

A byte value is a generic value which can store 8 bits.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@code{typedef char OV_BYTE;}

@strong{Remarks}

Byte values are not used in ACPLT/OV; however, opaque values are expressed
as byte vectors in ACPLT/KS. In ACPLT/OV this feature is used to allow to
generically transport variable values over ACPLT/KS which are not supported
by ACPLT/KS (e.g. user-defined datatypes).

Furthermore, sometimes it is necessary to calculate the difference between
to pointers in bytes. As ANSI C does not define a difference of 
@code{void*} pointers, for this purpose @code{OV_BYTE*} pointers are
used.

@c	--------------------------------

@node OV_ENUM, OV_POINTER, OV_BYTE, Fundamental datatypes
@section Generic enumeration value

A generic enumeration value can contain any possible value of an @code{enum}.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@code{typedef enum_t OV_ENUM;}

@strong{Remarks}

The datatype @code{enum_t} is declared in the Sun ONC/RPC header
@code{rpc/types.h} and falls back on the @code{int} datatype. 

The reason for using this datatype in ACPLT/OV is that using this declaration 
we do not need any conversion when encoding/decoding an enumeration value in 
ACPLT/OV into/from an XDR stream.

@c	--------------------------------

@node OV_POINTER, OV_BOOL_VEC, OV_ENUM, Fundamental datatypes
@section Generic pointer value

A generic pointer value can contain any possible value of a pointer to any 
datatype.

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@code{typedef void* OV_POINTER;}

@strong{Remarks}

Note, that ANSI C does not define a difference between @code{void*} pointers.
Even if some compilers (e.g. the GNU compiler) allow to calculate a 
@code{void}-pointer difference, you should @strong{never} do this with 
@code{OV_POINTER} pointers. Use @code{OV_BYTE*} pointers instead.

@c	--------------------------------

@node OV_BOOL_VEC, OV_INT_VEC, OV_POINTER, Fundamental datatypes
@section Dynamic bool value vector

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_UINT   veclen;
    OV_BOOL   *value;
@}   OV_BOOL_VEC;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_INT_VEC, OV_UINT_VEC, OV_BOOL_VEC, Fundamental datatypes
@section Dynamic signed integer value vector

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_UINT   veclen;
    OV_INT    *value;
@}   OV_INT_VEC;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_UINT_VEC, OV_SINGLE_VEC, OV_INT_VEC, Fundamental datatypes
@section Dynamic unsigned integer value vector

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_UINT   veclen;
    OV_UINT   *value;
@}   OV_UINT_VEC;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_SINGLE_VEC, OV_DOUBLE_VEC, OV_UINT_VEC, Fundamental datatypes
@section Dynamic single precision floating point value vector

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_UINT     veclen;
    OV_SINGLE   *value;
@}   OV_SINGLE_VEC;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_DOUBLE_VEC, OV_STRING_VEC, OV_SINGLE_VEC, Fundamental datatypes
@section Dynamic double precision floating point value vector

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_UINT     veclen;
    OV_DOUBLE   *value;
@}   OV_DOUBLE_VEC;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_STRING_VEC, OV_TIME_VEC, OV_DOUBLE_VEC, Fundamental datatypes
@section Dynamic string value vector

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_UINT     veclen;
    OV_STRING   *value;
@}   OV_STRING_VEC;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_TIME_VEC, OV_TIME_SPAN_VEC, OV_STRING_VEC, Fundamental datatypes
@section Dynamic time/date value vector

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_UINT   veclen;
    OV_TIME   *value;
@}   OV_TIME_VEC;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_TIME_SPAN_VEC, OV_GENERIC_VEC, OV_TIME_VEC, Fundamental datatypes
@section Dynamic time span value vector

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_UINT        veclen;
    OV_TIME_SPAN   *value;
@}   OV_TIME_SPAN_VEC;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_GENERIC_VEC, OV_BOOL_PV, OV_TIME_SPAN_VEC, Fundamental datatypes
@section Generic dynamic value vector (internal use)

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_UINT      veclen;
    OV_POINTER   value;
@}   OV_GENERIC_VEC;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_BOOL_PV, OV_INT_PV, OV_GENERIC_VEC, Fundamental datatypes
@section Boolean process value

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_BOOL    value;
    OV_STATE   state;
    OV_TIME    time;
@}   OV_BOOL_PV;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_INT_PV, OV_SINGLE_PV, OV_BOOL_PV, Fundamental datatypes
@section Integer process value

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_INT     value;
    OV_STATE   state;
    OV_TIME    time;
@}   OV_INT_PV;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_SINGLE_PV, OV_VAR_PROPS, OV_INT_PV, Fundamental datatypes
@section Single precision floating point process value

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_SINGLE   value;
    OV_STATE    state;
    OV_TIME     time;
@}   OV_SINGLE_PV;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_VAR_PROPS, OV_CLASS_PROPS, OV_SINGLE_PV, Fundamental datatypes
@section Variable properties

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_VP_GETACCESSOR   0x00000001       /* variable has a get accessor */
#define OV_VP_SETACCESSOR   0x00000002       /* variable has a set accessor */
#define OV_VP_ACCESSORS     (OV_VP_GETACCESSOR | OV_VP_SETACCESSOR)
#define OV_VP_DERIVED       0x00000004       /* variable is derived (virtual) */
#define OV_VP_STATIC        0x00000008       /* variable is static (class variable) */

typedef OV_ENUM   OV_VAR_PROPS;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_CLASS_PROPS, OV_ASSOC_PROPS, OV_VAR_PROPS, Fundamental datatypes
@section Class properties

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_CP_INSTANTIABLE   0x00000001       /* class is instantiable */
#define OV_CP_FINAL          0x00000002       /* class cannot be subclassed */

typedef OV_ENUM   OV_CLASS_PROPS;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_ASSOC_PROPS, OV_OP_PROPS, OV_CLASS_PROPS, Fundamental datatypes
@section Association properties

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_AP_LOCAL   0x00000001       /* association has local name scope */

typedef OV_ENUM   OV_ASSOC_PROPS;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_OP_PROPS, OV_TIME_TYPE, OV_ASSOC_PROPS, Fundamental datatypes
@section Operation properties

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_OP_ABSTRACT   0x00000001       /* operation is not implemented */

typedef OV_ENUM   OV_OP_PROPS;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_TIME_TYPE, OV_HSEL_TYPE, OV_OP_PROPS, Fundamental datatypes
@section Time types for use with ACPLT/KS histories

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define KS_TT_ABSOLUTE   0x00000000       /* TODO! should be defined in ks.h... */
#define KS_TT_RELATIVE   0x00000001       /* ...but is currently defined in selector.h */

#define OV_TT_ABSOLUTE   KS_TT_ABSOLUTE
#define OV_TT_RELATIVE   KS_TT_RELATIVE

typedef OV_ENUM   OV_TIME_TYPE;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_HSEL_TYPE, OV_HIST_TYPE, OV_TIME_TYPE, Fundamental datatypes
@section Selector types for use with ACPLT/KS histories

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define KS_HSELT_NONE     0x00000000       /* TODO! should be defined in ks.h... */
#define KS_HSELT_TIME     0x00000001       /* ...but is currently defined in selector.h */
#define KS_HSELT_STRING   0x00000002       /* dto. */

#define OV_HSELT_NONE     KS_HSELT_NONE
#define OV_HSELT_TIME     KS_HSELT_TIME
#define OV_HSELT_STRING   KS_HSELT_STRING

typedef OV_ENUM   OV_HSEL_TYPE;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_HIST_TYPE, OV_INTERPOLATION_MODE, OV_HSEL_TYPE, Fundamental datatypes
@section History types for use with ACPLT/KS histories

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_HT_LOG             KS_HT_LOG
#define OV_HT_BOOL            KS_HT_BOOL
#define OV_HT_INT             KS_HT_INT
#define OV_HT_UINT            KS_HT_UINT
#define OV_HT_SINGLE          KS_HT_SINGLE
#define OV_HT_DOUBLE          KS_HT_DOUBLE
#define OV_HT_STRING          KS_HT_STRING
#define OV_HT_TIME            KS_HT_TIME
#define OV_HT_TIME_SPAN       KS_HT_TIME_SPAN
#define OV_HT_TYPE_MASK       KS_HT_TYPE_MASK
#define OV_HT_TIME_DRIVEN     KS_HT_TIME_DRIVEN
#define OV_HT_CHANGE_DRIVEN   KS_HT_CHANGE_DRIVEN

typedef OV_ENUM   OV_HIST_TYPE;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_INTERPOLATION_MODE, OV_MSG_TYPE, OV_HIST_TYPE, Fundamental datatypes
@section Interpolation modes for use with ACPLT/KS histories

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_IPM_NONE      KS_IPM_NONE
#define OV_IPM_LINEAR    KS_IPM_LINEAR
#define OV_IPM_MIN       KS_IPM_MIN
#define OV_IPM_MAX       KS_IPM_MAX
#define OV_IPM_HOLD      KS_IPM_HOLD
#define OV_IPM_DEFAULT   KS_IPM_DEFAULT

typedef OV_ENUM   OV_INTERPOLATION_MODE;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_MSG_TYPE, , OV_INTERPOLATION_MODE, Fundamental datatypes
@section Type of a logfile message

@strong{Header file}

@code{#include "libov/ov_ov.h"}

@strong{Declaration}

@format
@t{#define OV_MT_UNKNOWN   0x00000000
#define OV_MT_INFO      0x00000001
#define OV_MT_DEBUG     0x00000002
#define OV_MT_WARNING   0x00000003
#define OV_MT_ERROR     0x00000004
#define OV_MT_ALERT     0x00000005

typedef OV_ENUM   OV_MSG_TYPE;}
@end format

@strong{Remarks}

@c	-----------
@c	Association
@c	-----------

@node Association, Class, Fundamental datatypes, Top
@chapter Functions and macros associated with associations

An association defines a relationship between parent and child objects
of given classes. It can be regarded as the class of all links of the same
type and all links of this type as instances of that class.

This means, that the functionality for iterating over or manipulating links
is associated with the association defining the link. 

The macros and functions implementing this functionality are generic and 
@strong{not type safe}. Whenever possible, you should use the macros defined 
in @code{libov/ov_macros.h} for improved type checking during compilation.

Macros for iterating over links of an association:
@menu
* Ov_Association_GetFirstChild()::            Get first child in a 1:n association.
* Ov_Association_GetLastChild()::             Get last child in a 1:n association.
* Ov_Association_GetNextChild()::             Get next child in a 1:n association.
* Ov_Association_GetPreviousChild()::         Get previous child in a 1:n association.
* Ov_Association_GetParent()::                Get parent in a 1:n association.
* Ov_Association_ForEachChild()::             Iterate over all children in a 1:n association.
* Ov_Association_DefineIteratorNM()::         Define an iterator for iterating over n:m associations.
* Ov_Association_GetFirstChildNM()::          Get first child in an n:m assocation.
* Ov_Association_GetLastChildNM()::           Get last child in an n:m assocation.
* Ov_Association_GetNextChildNM()::           Get next child in an n:m association.
* Ov_Association_GetPreviousChildNM()::       Get previous child in an n:m association.   
* Ov_Association_ForEachChildNM()::           Iterate over all children in an n:m association.
* Ov_Association_GetFirstParentNM()::         Get first parent in an n:m assocation.
* Ov_Association_GetLastParentNM()::          Get last parent in an n:m assocation
* Ov_Association_GetNextParentNM()::          Get next parent in an n:m association.
* Ov_Association_GetPreviousParentNM()::      Get previous parent in an n:m association.
* Ov_Association_ForEachParentNM()::          Iterate over all parents in an n:m association.
@end menu

Functions associated with links of an association:
@menu
* ov_association_searchchild()::              Search for a child object with a given identifier in a 1:n association
* ov_association_link()::                     Create a link between a child and a parent object.
* ov_association_unlink()::                   Remove a link between a child and a parent object.
* ov_association_getchildcount()::            Get the number of child objects.
* ov_association_isusedhead()::               Test whether a head of a link is used.
* ov_association_isusedanchor()::             Test whether an anchor of a link is used.
* ov_association_load()::                     Load an association into the database.
* ov_association_compare()::                  Compare an association with its definition.
* ov_association_canunload()::                Test if we can unload an association from the database.
* ov_association_getparentcount()::           Get the number of parent objects.
* ov_association_isusedparentlink()::         Test if a parent link is used.
* ov_association_isusedchildlink()::          Test if an child link is used.
@end menu

@c	--------------------------------

@node Ov_Association_GetFirstChild(), Ov_Association_GetLastChild(), Association, Association
@section Get first child in a 1:n association

The @code{Ov_Association_GetFirstChild()} macro returns a pointer of the first
child object of a link.

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pchild = Ov_Association_GetFirstChild(passoc, pparent);}

@strong{Parameters}

@table @code
@item @code{passoc}
Pointer to the association object defining the link.
@item @code{pparent}
Pointer to the parent object of the link.
@end table

@strong{Return value}

The macro returns a pointer to the first child object or @code{NULL} if no child objects 
exist.

@strong{Remarks}

This generic macro is @strong{not type safe}. Whenever possible, use the macro
@code{Ov_GetFirstChild()} instead!

@c	--------------------------------

@node Ov_Association_GetLastChild(), Ov_Association_GetNextChild(), Ov_Association_GetFirstChild(), Association
@section Get last child in a 1:n association

The @code{Ov_Association_GetLastChild()} macro returns a pointer of the last
child object of a link.

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pchild = Ov_Association_GetLastChild(passoc, pparent);}

@strong{Parameters}

@table @code
@item @code{passoc}
Pointer to the association object defining the link.
@item @code{pparent}
Pointer to the parent object of the link.
@end table

@strong{Return value}

The macro returns a pointer to the last child object or @code{NULL} if no child objects 
exist.

@strong{Remarks}

This generic macro is @strong{not type safe}. Whenever possible, use the macro
@code{Ov_GetLastChild()} instead!

@c	--------------------------------

@node Ov_Association_GetNextChild(), Ov_Association_GetPreviousChild(), Ov_Association_GetLastChild(), Association
@section Get next child in a 1:n association

The @code{Ov_Association_GetNextChild()} macro returns a pointer of the next
child object of a link.

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pchild = Ov_Association_GetNextChild(passoc, pchild);}

@strong{Parameters}

@table @code
@item @code{passoc}
Pointer to the association object defining the link.
@item @code{pchild}
Pointer to the current child object of the link.
@end table

@strong{Return value}

The macro returns a pointer to the next child object or @code{NULL} if the current 
child object is the last object of the link.

@strong{Remarks}

This generic macro is @strong{not type safe}. Whenever possible, use the macro
@code{Ov_GetNextChild()} instead!

@c	--------------------------------

@node Ov_Association_GetPreviousChild(), Ov_Association_GetParent(), Ov_Association_GetNextChild(), Association
@section Get previous child in a 1:n association

The @code{Ov_Association_GetPreviousChild()} macro returns a pointer of the previous
child object of a link.

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pchild = Ov_Association_GetPreviousChild(passoc, pchild);}

@strong{Parameters}

@table @code
@item @code{passoc}
Pointer to the association object defining the link.
@item @code{pchild}
Pointer to the current child object of the link.
@end table

@strong{Return value}

The macro returns a pointer to the previous child object or @code{NULL} if the current 
child object is the first object of the link.

@strong{Remarks}

This generic macro is @strong{not type safe}. Whenever possible, use the macro
@code{Ov_GetPrevChild()} instead!

@c	--------------------------------

@node Ov_Association_GetParent(), Ov_Association_ForEachChild(), Ov_Association_GetPreviousChild(), Association
@section Get parent in a 1:n association

The @code{Ov_Association_GetParent()} macro returns a pointer of the parent
object of a link.

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pparent = Ov_Association_GetParent(passoc, pchild);}

@strong{Parameters}

@table @code
@item @code{passoc}
Pointer to the association object defining the link.
@item @code{pchild}
Pointer to a child object of the link.
@end table

@strong{Return value}

The macro returns a pointer to the parent object or @code{NULL} if child object 
does not have a parent object.

@strong{Remarks}

This generic macro is @strong{not type safe}. Whenever possible, use the macro
@code{Ov_GetParent()} instead!

@c	--------------------------------

@node Ov_Association_ForEachChild(), Ov_Association_DefineIteratorNM(), Ov_Association_GetParent(), Association
@section Iterate over all children in a 1:n association

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{Ov_Association_ForEachChild(passoc, pparent, pchild);}

@strong{Parameters}

@table @code
@item passoc

@item pparent

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Association_DefineIteratorNM(), Ov_Association_GetFirstChildNM(), Ov_Association_ForEachChild(), Association
@section Define an iterator for iterating over n:m associations

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{Ov_Association_DefineIteratorNM(pit);}

@strong{Parameters}

@table @code
@item pit

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Association_GetFirstChildNM(), Ov_Association_GetLastChildNM(), Ov_Association_DefineIteratorNM(), Association
@section Get first child in an n:m assocation

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pchild = Ov_Association_GetFirstChildNM(passoc, pit, pparent);}

@strong{Parameters}

@table @code
@item passoc

@item pit

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Association_GetLastChildNM(), Ov_Association_GetNextChildNM(), Ov_Association_GetFirstChildNM(), Association
@section Get last child in an n:m assocation

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pchild = Ov_Association_GetLastChildNM(passoc, pit, pparent);}

@strong{Parameters}

@table @code
@item passoc

@item pit

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Association_GetNextChildNM(), Ov_Association_GetPreviousChildNM(), Ov_Association_GetLastChildNM(), Association
@section Get next child in an n:m association

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pchild = Ov_Association_GetNextChildNM(passoc, pit);}

@strong{Parameters}

@table @code
@item passoc

@item pit

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Association_GetPreviousChildNM(), Ov_Association_ForEachChildNM(), Ov_Association_GetNextChildNM(), Association
@section Get previous child in an n:m association

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pchild = Ov_Association_GetPreviousChildNM(passoc, pit);}

@strong{Parameters}

@table @code
@item passoc

@item pit

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Association_ForEachChildNM(), Ov_Association_GetFirstParentNM(), Ov_Association_GetPreviousChildNM(), Association
@section Iterate over all children in an n:m association

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{Ov_Association_ForEachChildNM(passoc, pit, pparent, pchild);}

@strong{Parameters}

@table @code
@item passoc

@item pit

@item pparent

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Association_GetFirstParentNM(), Ov_Association_GetLastParentNM(), Ov_Association_ForEachChildNM(), Association
@section Get first parent in an n:m assocation

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pparent = Ov_Association_GetFirstParentNM(passoc, pit, pchild);}

@strong{Parameters}

@table @code
@item passoc

@item pit

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Association_GetLastParentNM(), Ov_Association_GetNextParentNM(), Ov_Association_GetFirstParentNM(), Association
@section Get last parent in an n:m assocation

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pparent = Ov_Association_GetLastParentNM(passoc, pit, pchild);}

@strong{Parameters}

@table @code
@item passoc

@item pit

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Association_GetNextParentNM(), Ov_Association_GetPreviousParentNM(), Ov_Association_GetLastParentNM(), Association
@section Get next parent in an n:m association

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pparent = Ov_Association_GetNextParentNM(passoc, pit);}

@strong{Parameters}

@table @code
@item passoc

@item pit

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Association_GetPreviousParentNM(), Ov_Association_ForEachParentNM(), Ov_Association_GetNextParentNM(), Association
@section Get previous parent in an n:m association

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{pparent = Ov_Association_GetPreviousParentNM(passoc, pit);}

@strong{Parameters}

@table @code
@item passoc

@item pit

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node Ov_Association_ForEachParentNM(), ov_association_searchchild(), Ov_Association_GetPreviousParentNM(), Association
@section Iterate over all parents in an n:m association

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Macro usage}

@code{Ov_Association_ForEachParentNM(passoc, pit, pchild, pparent);}

@strong{Parameters}

@table @code
@item passoc

@item pit

@item pchild

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_association_searchchild(), ov_association_link(), Ov_Association_ForEachParentNM(), Association
@section Search for a child object with a given identifier in a 1:n association

The @code{ov_association_searchchild()} function returns a pointer to the child
object of a namebinding link with a given identifier.

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_INSTPTR_ov_object ov_association_searchchild(
    const OV_INSTPTR_ov_association passoc,
    const OV_INSTPTR_ov_object      pparent,
    const OV_STRING                 identifier
);}
@end format

@strong{Parameters}

@table @code
@item @code{passoc}
Pointer to the association object defining the link. Note, that the association
must be namebinding; a @code{NULL} pointer is returned otherwise.
@item @code{pparent}
Pointer to the parent object of the link.
@item @code{identifier}
Pointer to a string which must match the identifier of the child object.
@end table

@strong{Return value}

The function returns a pointer to the child object or @code{NULL} no child is found or
the association is not namebinding.

@strong{Remarks}

This generic function is @strong{not type safe}. Whenever possible, use the macro
@code{Ov_SearchChild()} instead!

@c	--------------------------------

@node ov_association_link(), ov_association_unlink(), ov_association_searchchild(), Association
@section Create a link between a child and a parent object

The @code{ov_association_link()} function creates a link between a child and 
a parent object. 

The link can not be created, if the child object already has a parent object of the 
type given by the association or if the link is namebinding and a the child object 
has the same identifier as another child object of the parent object.

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_association_link(
    const OV_INSTPTR_ov_association passoc,
    const OV_INSTPTR_ov_object      pparent,
    const OV_INSTPTR_ov_object      pchild,
    const OV_PLACEMENT_HINT         hint,
    const OV_INSTPTR_ov_object      prelchild
);}
@end format

@strong{Parameters}

@table @code
@item @code{passoc}
Pointer to the association object defining the link.
@item @code{pparent}
Pointer to the object which will be the parent object of the new link.
@item @code{pchild}
Pointer to the object which will be the child object of the new link.
@item @code{hint}
Placement hint indicating the position of the child object compared to other
child objects of the parent of the new link.
@item @code{prelchild}
If @code{hint == OV_PMH_BEFORE} or @code{hint == OV_PMH_AFTER}, this parameter is
a pointer to a child object before/after which the child object of the new
link will be placed; otherwise this parameter is ignored. The child object pointed 
to by @code{prelchild} must alreay be a child of the parent object.
@end table

@strong{Return value}

The function returns @code{OV_ERR_OK} if it succeeds or the error code otherwise.

@strong{Remarks}

This generic function is @strong{not type safe}. Whenever possible, use the macro
@code{Ov_Link()} instead!

@c	--------------------------------

@node ov_association_unlink(), ov_association_getchildcount(), ov_association_link(), Association
@section Remove a link between a child and a parent object

The @code{ov_association_unlink()} function removes a link between a child 
and a parent object. 

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_association_unlink(
    const OV_INSTPTR_ov_association passoc,
    const OV_INSTPTR_ov_object      pparent,
    const OV_INSTPTR_ov_object      pchild
);}
@end format

@strong{Parameters}

@table @code
@item @code{passoc}
Pointer to the association object defining the link.
@item @code{pparent}
Pointer to the parent object of the link to be removed.
@item @code{pchild}
Pointer to the child object of the link to be removed.
@end table

@strong{Remarks}

This generic function is @strong{not type safe}. Whenever possible, use the macro
@code{Ov_Unlink()} instead!

@c	--------------------------------

@node ov_association_getchildcount(), ov_association_isusedhead(), ov_association_unlink(), Association
@section Get the number of child objects

The @code{ov_association_getchildcount()} function returns the number of child 
objects linked to a given parent object.

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_UINT ov_association_getchildcount(
    const OV_INSTPTR_ov_association passoc,
    const OV_INSTPTR_ov_object      pparent
);}
@end format

@strong{Parameters}

@table @code
@item @code{passoc}
Pointer to the association object defining the link.
@item @code{pparent}
Pointer to the parent object.
@end table

@strong{Return value}

The function returns the number of child objects linked to the parent object.

@c	--------------------------------

@node ov_association_isusedhead(), ov_association_isusedanchor(), ov_association_getchildcount(), Association
@section Test whether a head of a link is used

The @code{ov_association_isusedhead()} function tests whether a head of a link 
is used (i.e. the parent object owning the head has child objects) or not.

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_BOOL ov_association_isusedhead(
    const OV_INSTPTR_ov_association passoc,
    const OV_INSTPTR_ov_object      pparent
);}
@end format

@strong{Parameters}

@table @code
@item @code{passoc}
Pointer to the association object defining the link.
@item @code{pparent}
Pointer to the parent object owning the head of the link.
@end table

@strong{Return value}

The function returns @code{TRUE} if the head is used and @code{FALSE} otherwise.

@c	--------------------------------

@node ov_association_isusedanchor(), ov_association_load(), ov_association_isusedhead(), Association
@section Test whether an anchor of a link is used

The @code{ov_association_isusedanchor()} function tests whether an anchor of a 
link is used (i.e. the child object owning the anchor has a parent object) or not.

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_BOOL ov_association_isusedanchor(
    const OV_INSTPTR_ov_association passoc,
    const OV_INSTPTR_ov_object      pchild
);}
@end format

@strong{Parameters}

@table @code
@item @code{passoc}
Pointer to the association object defining the link.
@item @code{pchild}
Pointer to the child object owning the anchor of the link.
@end table

@strong{Return value}

The function returns @code{TRUE} if the anchor is used and @code{FALSE} otherwise.

@c	--------------------------------

@node ov_association_load(), ov_association_compare(), ov_association_isusedanchor(), Association
@section Load an association into the database

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Declaration}

@format
@t{OV_RESULT ov_association_load(
    OV_ASSOCIATION_DEF     *passocdef,
    OV_INSTPTR_ov_domain   pparent
);}
@end format

@strong{Parameters}

@table @code
@item passocdef

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_association_compare(), ov_association_canunload(), ov_association_load(), Association
@section Compare an association with its definition

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Declaration}

@format
@t{OV_RESULT ov_association_compare(
    OV_INSTPTR_ov_association   passoc,
    OV_ASSOCIATION_DEF          *passocdef
);}
@end format

@strong{Parameters}

@table @code
@item passoc

@item passocdef

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_association_canunload(), ov_association_getparentcount(), ov_association_compare(), Association
@section Test if we can unload an association from the database

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Declaration}

@format
@t{OV_BOOL ov_association_canunload(
    OV_INSTPTR_ov_association   passoc
);}
@end format

@strong{Parameters}

@table @code
@item passoc

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_association_getparentcount(), ov_association_isusedparentlink(), ov_association_canunload(), Association
@section Get the number of parents of an association

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_UINT ov_association_getparentcount(
    const OV_INSTPTR_ov_association   passoc,
    const OV_INSTPTR_ov_object        pchild
);}
@end format

@strong{Parameters}

@table @code
@item passoc

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_association_isusedparentlink(), ov_association_isusedchildlink(), ov_association_getparentcount(), Association
@section Test if a parent link is used

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_BOOL ov_association_isusedparentlink(
    const OV_INSTPTR_ov_association   passoc,
    const OV_INSTPTR_ov_object        pparent
);}
@end format

@strong{Parameters}

@table @code
@item passoc

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_association_isusedchildlink(), , ov_association_isusedparentlink(), Association
@section Test if a child link is used

@strong{Header file}

@code{#include "libov/ov_association.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_BOOL ov_association_isusedchildlink(
    const OV_INSTPTR_ov_association   passoc,
    const OV_INSTPTR_ov_object        pchild
);}
@end format

@strong{Parameters}

@table @code
@item passoc

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	-----
@c	Class
@c	-----

@node Class, Database, Association, Top
@chapter Datatypes and functions associated with classes

A class is an abstraction of objects with the same data structure and the same
operations; these objects are called instances of the class.

A class can be regarded as a factory responsible for creating and deleting 
instances.

Datatypes associated with classes:
@menu
* OV_FNC_INITOBJ::          Function prototype of an initialization function.
@end menu

Functions associated with classes:
@menu
* ov_class_createobject()::  Create an instance of a class.
* ov_class_deleteobject()::  Delete an instance of a class.
* ov_class_cancastto()::     Test if a pointer cast of an instance pointer is allowed.
* ov_class_search()::        Search for a class object with given identifier.
* ov_class_load()::          Load a class into the database.
* ov_class_compare()::       Compare a class with its definition.
* ov_class_canunload()::     Test if we can unload a class from the database.
* ov_class_renameobject()::  Rename an instance of a class.

@end menu

@c	--------------------------------

@node OV_FNC_INITOBJ, ov_class_createobject(), Class, Class
@section Function prototype of an initialization function

The function prototype @code{OV_FNC_INITOBJ} is used for defining initialization
functions, which are called during instantiation of an object using the
function @code{ov_class_createobject()}.

@strong{Header file}

@code{#include "libov/ov_class.h"}

@strong{Declaration}

@format
@t{typedef OV_RESULT OV_FNC_INITOBJ(
    OV_INSTPTR_ov_object pobj,
    OV_POINTER           userdata
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the instance object to be initialized during instantiation.
@item @code{userdata}
Generic pointer to a user defined data structure containing information which is
necessary for initialization of the object to be initialized.
@end table

@strong{Return value}

Functions of this type must return @code{OV_ERR_OK} if the initialization succeeds 
or an error code otherwise.

@c	--------------------------------

@node ov_class_createobject(), ov_class_deleteobject(), OV_FNC_INITOBJ, Class
@section Create an instance of a class

The @code{ov_class_createobject()} function creates a new instance object
of a class, initializes it and starts it up.

The instance can not be created if there is not enough memory available in the
database, if the class is not instantiable, if an object with the given identifier 
already exists in the parent domain, if the initialization of the object fails or 
if the constructor of the object returns an error code other than @code{OV_ERR_OK}.

@strong{Header file}

@code{#include "libov/ov_class.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_class_createobject(
    const OV_INSTPTR_ov_class  pclass,
    const OV_INSTPTR_ov_domain pparent,
    const OV_STRING            identifier,
    const OV_PLACEMENT_HINT    hint,
    const OV_INSTPTR_ov_object prelchild,
    OV_FNC_INITOBJ             *initobjfnc,
    OV_POINTER                 userdata,
    OV_INSTPTR_ov_object       *ppobj
);}
@end format

@strong{Parameters}

@table @code
@item @code{pclass}
Pointer to the class object defining the class to be instantiated. The class must
be instantiable.
@item @code{pparent}
Pointer to the parent domain object which will contain the new instance object.
@item @code{identifier}
String containing the identifier of the new instance object.
@item @code{hint}
Placement hint indicating the position of the new instance object compared to other
objects contained in the parent domain object.
@item @code{prelchild}
If @code{hint == OV_PMH_BEFORE} or @code{hint == OV_PMH_AFTER}, this parameter is
a pointer to a child object contained in the parent domain before/after which the 
new instance object will be placed; otherwise this parameter is ignored. The child 
object pointed to by @code{prelchild} must alreay be a child of the parent domain
object.
@item @code{initobjfnc}
Pointer to a function with the function prototype @code{OV_FNC_INITOBJ},
which will be called for initialization of the new instance object or @code{NULL}.
When this function is called during instantiation, the pointer to the instance 
object and a generic pointer to a user defined data structure is passed to
the function. The function must then return a function result. If this result
is not @code{OV_ERR_OK} instantiation of the object fails and the new instance
object will be deleted.
@item @code{userdata}
Generic pointer to a user defined data structure containing information which is
necessary for initialization of the new instance object. This parameter is passed
to the initialization function specified by @code{initobjfnc}.
@item @code{ppobj}
Pointer to the instance object pointer of the new instance object.
@end table

@strong{Return value}

The function returns @code{OV_ERR_OK} if it succeeds or the error code otherwise.
If the function succeeds, the instance object pointer pointed to by the @code{ppobj}
parameter contains the address of the new instance object or @code{NULL} otherwise.

@c	--------------------------------

@node ov_class_deleteobject(), ov_class_cancastto(), ov_class_createobject(), Class
@section Delete an instance of a class

The @code{ov_class_deleteobject()} function deletes an instance object. Before
the instance object is actually deleted, it is shut down and its destructor
is called.

An instance object can not be deleted if it is a part of another object.

@strong{Header file}

@code{#include "libov/ov_class.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_class_deleteobject(
    const OV_INSTPTR_ov_object pobj
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the instance object to be deleted.
@end table

@strong{Return value}

The function returns @code{OV_ERR_OK} if it succeeds or the error code otherwise.

@c	--------------------------------

@node ov_class_cancastto(), ov_class_search(), ov_class_deleteobject(), Class
@section Test if a pointer cast of an instance pointer is allowed

The @code{ov_class_cancastto()} dynamically tests if a typecast from a 
pointer to an instance of one class, the "from" class, can be to a pointer 
to an instance of another class, the "to" class, is allowed or not. Such
a typecast is allowed, if the "from" class is derived from the "to" class.

@strong{Header file}

@code{#include "libov/ov_class.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_BOOL ov_class_cancastto(
    const OV_INSTPTR_ov_class pclassfrom,
    const OV_INSTPTR_ov_class pclassto
);}
@end format

@strong{Parameters}

@table @code
@item @code{pclassfrom}
Pointer to the class object defining the "from" class.
@item @code{pclassto}
Pointer to the class object defining the "to" class.
@end table

@strong{Return value}

The function returns @code{TRUE} if the typecast is allowed or @code{FALSE}
otherwise.

@c	--------------------------------

@node ov_class_search(), ov_class_load(), ov_class_cancastto(), Class
@section Search for a class object with given identifier

@strong{Header file}

@code{#include "libov/ov_class.h"}

@strong{Declaration}

@format
@t{OV_INSTPTR_ov_class ov_class_search(
    OV_STRING   identifier
);}
@end format

@strong{Parameters}

@table @code
@item identifier

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_class_load(), ov_class_compare(), ov_class_search(), Class
@section Load a class into the database

@strong{Header file}

@code{#include "libov/ov_class.h"}

@strong{Declaration}

@format
@t{OV_RESULT ov_class_load(
    OV_CLASS_DEF           *pclassdef,
    OV_INSTPTR_ov_domain   pparent
);}
@end format

@strong{Parameters}

@table @code
@item pclassdef

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_class_compare(), ov_class_canunload(), ov_class_load(), Class
@section Compare a class with its definition

@strong{Header file}

@code{#include "libov/ov_class.h"}

@strong{Declaration}

@format
@t{OV_RESULT ov_class_compare(
    OV_INSTPTR_ov_class   pclass,
    OV_CLASS_DEF          *pclassdef
);}
@end format

@strong{Parameters}

@table @code
@item pclass

@item pclassdef

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_class_canunload(), ov_class_renameobject(), ov_class_compare(), Class
@section Test if we can unload a class from the database

@strong{Header file}

@code{#include "libov/ov_class.h"}

@strong{Declaration}

@format
@t{OV_BOOL ov_class_canunload(
    OV_INSTPTR_ov_class   pclass
);}
@end format

@strong{Parameters}

@c @table @code
@c @item

@c @end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_class_renameobject(), , ov_class_canunload(), Class
@section Rename an instance of a class

@strong{Header file}

@code{#include "libov/ov_class.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_class_renameobject(
    const OV_INSTPTR_ov_object   pobj,
    const OV_INSTPTR_ov_domain   pparent,
    const OV_STRING              identifier,
    const OV_PLACEMENT_HINT      hint,
    const OV_INSTPTR_ov_object   prelobj
);}
@end format

@strong{Parameters}

@table @code
@item pobj

@item pparent

@item identifier

@item hint

@item prelobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------
@c	Database
@c	--------

@node Database, Element, Class, Top
@chapter Functions associated with the database

ACPLT/OV applications always run on exactly one database. The database usually
is a memory mapped file and stores the application's objects as well as the
meta objects defined in the libraries of the application. The objects stored
in the database are persistent, i.e. they survive if you stop the application
process and restart it later.

Functions associated with the database file:
@menu
* ov_database_create()::   Create a new database.
* ov_database_map()::      Map an existing database.
* ov_database_unmap()::    Unmap the mapped database.
* ov_database_flush()::    Flush the contents of the mapped database.
@end menu

Functions for startup and shutdown of the objects:
@menu
* ov_database_startup()::  Start up the objects in the database.
* ov_database_shutdown():: Shut down the objects in the database.
@end menu

Database memory management functions:
@menu
* ov_database_malloc()::   Allocate persistent database memory.
* ov_database_realloc()::  Reallocate persistent database memory.
* ov_database_free()::     Free persistent database memory.
@end menu

Database memory usage statistics functions:
@menu
* ov_database_getsize()::  Get the total size of the database memory.
* ov_database_getfree()::  Get the size of the free database memory.
* ov_database_getused()::  Get the size of the used database memory.
* ov_database_getfrag()::  Get the fragmentation of the database memory.
@end menu

@c	--------------------------------

@node ov_database_create(), ov_database_map(), Database, Database
@section Create a new database

The @code{ov_database_create()} function creates a new database file,
maps the file into the application's address space and loads the OV library 
(the OV meta model).

The function can only succeed if no database is mapped.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_database_create(
    OV_STRING filename,
    OV_UINT   size
);}
@end format

@strong{Parameters}

@table @code
@item @code{filename}
The filename of the new database. The file must not yet exist.
@item @code{size}
The initial size of the new database (in bytes). The actual database size
is rounded up to a multiple of the memory page size.
@end table

@strong{Return value}

The function returns @code{OV_ERR_OK} if it succeeds or the error code otherwise.

@c	--------------------------------

@node ov_database_map(), ov_database_unmap(), ov_database_create(), Database
@section Map an existing database

The @code{ov_database_map()} function opens an existing database file and
maps it into the application's address space.

The function can only succeed if no database is mapped and the database file
is not used by another application.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_database_map(
    OV_STRING filename
);}
@end format

@strong{Parameters}

@table @code
@item @code{filename}
The filename of the existing database. The file must already exist and at least
contain a consistent OV library.
@end table

@strong{Return value}

The function returns @code{OV_ERR_OK} if it succeeds or the error code otherwise.

@c	--------------------------------

@node ov_database_unmap(), ov_database_flush(), ov_database_map(), Database
@section Unmap the mapped database

The @code{ov_database_unmap()} function unmaps the current database file from
the application's address space and closes it.

The function can only succeed if no database is mapped.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT void ov_database_unmap(void);}

@strong{Remarks}

Before a database which was started up using 
@code{ov_database_startup()} is unmapped, it has to be shut down by calling
@code{ov_database_shutdown()}. 

If no database is mapped, the function has no effect.

@c	--------------------------------

@node ov_database_flush(), ov_database_startup(), ov_database_unmap(), Database
@section Flush the contents of the mapped database

The @code{ov_database_flush()} function synchronously flushes the the contents
of the database memory into the database file.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT void ov_database_flush(void);}

@strong{Remarks}

If no database is mapped, the function has no effect.

@c	--------------------------------

@node ov_database_startup(), ov_database_shutdown(), ov_database_flush(), Database
@section Start up the objects in the database

The @code{ov_database_startup()} function loads all libraries and starts up the 
objects stored in the mapped database by calling the root object's @code{startup} 
method.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT OV_RESULT ov_database_startup(void);}

@strong{Return value}

The function returns @code{OV_ERR_OK} if it succeeds or the error code otherwise.

@strong{Remarks}

If no database is mapped, the function has no effect.

@c	--------------------------------

@node ov_database_shutdown(), ov_database_malloc(), ov_database_startup(), Database
@section Shut down the objects in the database

The @code{ov_database_shutdown()} function shuts down the objects stored in the 
mapped database by calling the root object's @code{shutdown} method.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT void ov_database_shutdown(void);}

@strong{Remarks}

If no database is mapped, the function has no effect.

@c	--------------------------------

@node ov_database_malloc(), ov_database_realloc(), ov_database_shutdown(), Database
@section Allocate persistent database memory

Similar to the ANSI C @code{malloc()} function, @code{ov_database_malloc()}
allocates a memory block of a given size and returns its pointer. While
@code{malloc()} allocates the memory on the system heap, 
@code{ov_database_malloc()} allocates the memory in the persistent database.

If there's no memory block available in the database, the system tries to
increase the database file and map the new part of the file to memory. If
does not succeed, the function fails.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_POINTER ov_database_malloc(
    OV_UINT size
);}
@end format

@strong{Parameters}

@table @code
@item @code{size}
The amount of persistent memory to allocate in the database (in bytes).
@end table

@strong{Return value}

The function returns a pointer to the allocated memory block if it succeeds 
or @code{NULL} otherwise.

@strong{Remarks}

Even if @code{ov_database_getfree()} returns a value greater than 
@code{size} the function may return @code{NULL} if no block of the
given size is available due to fragmentation.

If no database is mapped, the function always returns @code{NULL}.

@c	--------------------------------

@node ov_database_realloc(), ov_database_free(), ov_database_malloc(), Database
@section Reallocate persistent database memory

Similar to the ANSI C @code{realloc()} function, @code{ov_database_realloc()}
reallocates a memory block previously allocated using @code{ov_database_malloc()}
or @code{ov_database_realloc()} of a given size and returns its pointer. While
@code{realloc()} reallocates the memory on the system heap, 
@code{ov_database_realloc()} reallocates the memory in the persistent database.

If the new memory block is at least as large as the old block, the full contents 
of the old block is copied to the new block; if it is smaller than the old block,
only the @code{size} first bytes from the old block are copied to the new block.

If there's no memory block available in the database, the system tries to
increase the database file and map the new part of the file to memory. If
does not succeed, the function fails.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_POINTER ov_database_realloc(
    OV_POINTER ptr,
    OV_UINT    size
);}
@end format

@strong{Parameters}

@table @code
@item ptr
Pointer to the memory block previously allocated in the database. If 
@code{ptr} is @code{NULL}, this function is equivalent to 
@code{ov_database_malloc(size)}.
@item size
The amount of persistent memory to reallocate in the database (in bytes).
@end table

@strong{Return value}

The function returns a pointer to the reallocated memory block if it succeeds 
or @code{NULL} otherwise.

@strong{Remarks}

Even if @code{ov_database_getfree()} returns a value greater than 
@code{size} the function may return @code{NULL} if no block of the
given size is available due to fragmentation.

If no database is mapped, the function always returns @code{NULL}.

@c	--------------------------------

@node ov_database_free(), ov_database_getsize(), ov_database_realloc(), Database
@section Free persistent database memory

Similar to the ANSI C @code{free()} function, @code{ov_database_free()}
frees a memory block previously allocated using @code{ov_database_malloc()}
or @code{ov_database_realloc()}. While @code{free()} frees memory 
allocated on the system heap, @code{ov_database_free()} frees memory 
allocated in the persistent database.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_database_free(
    OV_POINTER ptr
);}
@end format

@strong{Parameters}

@table @code
@item ptr
Pointer to the memory block in the database that has to be freed.
@end table

@strong{Remarks}

If no database is mapped, the function has no effect.

@c	--------------------------------

@node ov_database_getsize(), ov_database_getfree(), ov_database_free(), Database
@section Get the total size of the database memory

The @code{ov_database_getsize()} function returns the total amount of memory 
the mapped database contains. Usually this size is equal the file size of 
the database file.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT OV_UINT ov_database_getsize(void);}

@strong{Return value}

The function returns the total amount of memory in the mapped
database (in bytes).

@strong{Remarks}

If no database is mapped, the function returns @code{0}.

@c	--------------------------------

@node ov_database_getfree(), ov_database_getused(), ov_database_getsize(), Database
@section Get the size of the free database memory

The @code{ov_database_getfree()} function returns the amount of free
(unused) memory the mapped database contains.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT OV_UINT ov_database_getfree(void);}

@strong{Return value}

The function returns the amount of free memory in the mapped
database (in bytes).

@strong{Remarks}

If no database is mapped, the function returns @code{0}.

@c	--------------------------------

@node ov_database_getused(), ov_database_getfrag(), ov_database_getfree(), Database
@section Get the size of the used database memory

The @code{ov_database_getused()} function returns the amount of used
(allocated) memory the mapped database contains.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT OV_UINT ov_database_getused(void);}

@strong{Return value}

The function returns the amount of used memory in the mapped
database (in bytes).

@strong{Remarks}

If no database is mapped, the function returns @code{0}.

@c	--------------------------------

@node ov_database_getfrag(), , ov_database_getused(), Database
@section Get the fragmentation of the database memory

The @code{ov_database_getfrag()} function returns a rough indication
of the degree of fragmentation of the database memory in percent (0..100). If 
this value is low, chances are high that it is possible to allocate a new
database memory block without increasing the database size.

Basically, the underlying algorithm determines the precentage of free memory 
that can not be used to allocate memory blocks of average object size.

@strong{Header file}

@code{#include "libov/ov_database.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT OV_UINT ov_database_getfrag(void);}

@strong{Return value}

The function returns the degree of memory fragmentation of the mapped
database (in percent).

@strong{Remarks}

If no database is mapped, the function returns @code{100}.

@c	-------
@c	Element
@c	-------

@node Element, Library, Database, Top
@chapter Datatypes and functions associated with elements

An element is either an object or a part of an object, i.e. a variable, an end
of a link (head or anchor), a part object, an operation or a member of a 
structured variable and can be identified by a unique path. Each element is 
either a child or a part of another element except for the element corresponding 
to the root object. This relationship is expressed in the path identifying
the element, e.g. in @code{parent/child} the @code{child} element is a child
of the @code{parent} element and in @code{composite.part} the @code{part}
element is a part of the @code{composite} element.

Datatypes associated with elements:
@menu
* OV_ELEM_TYPE::                Type of an element.
* OV_ELEMENT::                  Information associated with an element.
@end menu

Functions associated with elements:
@menu
* ov_element_searchchild()::    Search a child element of an element.
* ov_element_searchpart()::     Search a part element of an element.
* ov_element_getnextchild()::   Get next child element of an element.
* ov_element_getnextpart()::    Get next part element of an element.
* ov_element_getidentifier()::  Get the identifier of an element.
@end menu

@c	--------------------------------

@node OV_ELEM_TYPE, OV_ELEMENT, Element, Element
@section Type of an element

@strong{Header file}

@code{#include "libov/ov_element.h"}

@strong{Declaration}

@format
@t{enum OV_ELEM_TYPE_ENUM @{
    OV_ET_NONE         = 0x00,       /* invalid element */
    OV_ET_OBJECT       = 0x01,
    OV_ET_VARIABLE     = 0x02,
    OV_ET_MEMBER       = 0x04,
    OV_ET_PARENTLINK   = 0x08,
    OV_ET_CHILDLINK    = 0x10,
    OV_ET_OPERATION    = 0x20,
    OV_ET_ANY          = 0x3F        /* used for search masks only */
@};

typedef enum_t   OV_ELEM_TYPE;}
@end format

@strong{Remarks}

@c	--------------------------------

@node OV_ELEMENT, ov_element_searchchild(), OV_ELEM_TYPE, Element
@section Information associated with an element

@strong{Header file}

@code{#include "libov/ov_element.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_ELEM_TYPE                        elemtype;       /* the type of the element */
    struct OV_INST_ov_object            *pobj;          /* object this element belongs to */
    /* in case element is a variable or member of a variable: */
    OV_BYTE                             *pvalue;        /* pointer to variable value */
    /* in different cases: */
    union @{
        /* generic definition object pointer */
        struct OV_INST_ov_object        *pobj;
        /* in case element is a variable or member of a variable: */
        struct OV_INST_ov_variable      *pvar;
        /* in case element is a part object: */
        struct OV_INST_ov_part          *ppart;
        /* in case element is a parent or child link: */
        struct OV_INST_ov_association   *passoc;
        /* in case element is an operation: */
        struct OV_INST_ov_operation     *pop;
        /* in case element is a class: */
        struct OV_INST_ov_class         *pclass;
    @}   elemunion;
@}   OV_ELEMENT;}
@end format

@strong{Remarks}

@c	--------------------------------

@node ov_element_searchchild(), ov_element_searchpart(), OV_ELEMENT, Element
@section Search a child element of an element

@strong{Header file}

@code{#include "libov/ov_element.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_element_searchchild(
    const OV_ELEMENT   *pparent,
    OV_ELEMENT         *pchild,
    OV_STRING          identifier
);}
@end format

@strong{Parameters}

@table @code
@item pparent

@item pchild

@item identifier

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_element_searchpart(), ov_element_getnextchild(), ov_element_searchchild(), Element
@section Search a part element of an element

@strong{Header file}

@code{#include "libov/ov_element.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_element_searchpart(
    const OV_ELEMENT   *pparent,
    OV_ELEMENT         *ppart,
    OV_ELEM_TYPE       mask,
    OV_STRING          identifier
);}
@end format

@strong{Parameters}

@table @code
@item pparent

@item ppart

@item mask

@item identifier

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_element_getnextchild(), ov_element_getnextpart(), ov_element_searchpart(), Element
@section Get next child element of an element

@strong{Header file}

@code{#include "libov/ov_element.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_element_getnextchild(
    const OV_ELEMENT   *pparent,
    OV_ELEMENT         *pchild
);}
@end format

@strong{Parameters}

@table @code
@item pparent

@item pchild

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_element_getnextpart(), ov_element_getidentifier(), ov_element_getnextchild(), Element
@section Get next part element of an element

@strong{Header file}

@code{#include "libov/ov_element.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_element_getnextpart(
    const OV_ELEMENT   *pparent,
    OV_ELEMENT         *ppart,
    OV_ELEM_TYPE       mask
);}
@end format

@strong{Parameters}

@table @code
@item pparent

@item ppart

@item mask

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_element_getidentifier(), , ov_element_getnextpart(), Element
@section Get the identifier of an element

@strong{Header file}

@code{#include "libov/ov_element.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_STRING ov_element_getidentifier(
    const OV_ELEMENT   *pelem
);}
@end format

@strong{Parameters}

@table @code
@item pelem

@end table

@strong{Return value}

@strong{Remarks}

@c	-------
@c	Library
@c	-------

@node Library, Logfile, Element, Top
@chapter Functions associated with libraries

@menu
* ov_library_search()::      Search for a library object with given identifier.
* ov_library_open()::        Open a library which is either a DLL/shared library or statically linked.
* ov_library_close()::       Close a library file if it is a DLL/shared library.
* ov_library_load()::        Load a library and its definitions into the database.
* ov_library_compare()::     Compare a library with its definition.
* ov_library_canunload()::   Test if we can unload a library and its definitions from the database.
* ov_library_getenv()::      Get environment variable with library path.
* ov_library_setenv()::      Set environment variable with library path.
@end menu

@c	--------------------------------

@node ov_library_search(), ov_library_open(), Library, Library
@section Search for a library object with given identifier

@strong{Header file}

@code{#include "libov/ov_library.h"}

@strong{Declaration}

@format
@t{OV_INSTPTR_ov_library ov_library_search(
    OV_STRING   identifier
);}
@end format

@strong{Parameters}

@table @code
@item identifier

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_library_open(), ov_library_close(), ov_library_search(), Library
@section Open a library which is either a DLL/shared library or statically linked

@strong{Header file}

@code{#include "libov/ov_library.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_LIBRARY_DEF *ov_library_open(
    OV_INSTPTR_ov_library   plib
);}
@end format

@strong{Parameters}

@table @code
@item plib

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_library_close(), ov_library_load(), ov_library_open(), Library
@section Close a library file if it is a DLL/shared library

@strong{Header file}

@code{#include "libov/ov_library.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_library_close(
    OV_INSTPTR_ov_library   plib
);}
@end format

@strong{Parameters}

@table @code
@item plib

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_library_load(), ov_library_compare(), ov_library_close(), Library
@section Load a library and its definitions into the database

@strong{Header file}

@code{#include "libov/ov_library.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_library_load(
    OV_INSTPTR_ov_library   plib,
    OV_LIBRARY_DEF          *plibdef
);}
@end format

@strong{Parameters}

@table @code
@item plib

@item plibdef

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_library_compare(), ov_library_canunload(), ov_library_load(), Library
@section Compare a library with its definition

@strong{Header file}

@code{#include "libov/ov_library.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_library_compare(
    OV_INSTPTR_ov_library   plib,
    OV_LIBRARY_DEF          *plibdef
);}
@end format

@strong{Parameters}

@table @code
@item plib

@item plibdef

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_library_canunload(), ov_library_getenv(), ov_library_compare(), Library
@section Test if we can unload a library and its definitions from the database

@strong{Header file}

@code{#include "libov/ov_library.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_BOOL ov_library_canunload(
    OV_INSTPTR_ov_library   plib
);}
@end format

@strong{Parameters}

@table @code
@item plib

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_library_getenv(), ov_library_setenv(), ov_library_canunload(), Library
@section Get environment variable with library path

@strong{Header file}

@code{#include "libov/ov_library.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT OV_STRING ov_library_getenv(void);}

@strong{Parameters}

none

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_library_setenv(), , ov_library_getenv(), Library
@section Set environment variable with library path

@strong{Header file}

@code{#include "libov/ov_library.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_library_setenv(
    OV_STRING   path
);}
@end format

@strong{Parameters}

@table @code
@item path

@end table

@strong{Return value}

@strong{Remarks}

@c	-------
@c	Logfile
@c	-------

@node Logfile, Malloc, Library, Top
@chapter Functions associated with logfiles

@menu
* ov_logfile_open()::          Open/create a logfile.
* ov_logfile_close()::         Close the logfile.
* ov_logfile_logtostdout()::   Log to stdout.
* ov_logfile_logtostderr()::   Log to stderr.
* ov_logfile_logtontlog()::    Log to the NT logger (Windows NT only).
* ov_logfile_print()::         Print text to logfile.
* ov_logfile_info()::          Print info to logfile.
* ov_logfile_debug()::         Print debug info to logfile.
* ov_logfile_warning()::       Print warning to logfile.
* ov_logfile_error()::         Print error to logfile.
* ov_logfile_alert()::         Print alert to logfile.
* ov_logfile_getmessages()::   Get messages from the logfile.
@end menu

@c	--------------------------------

@node ov_logfile_open(), ov_logfile_close(), Logfile, Logfile
@section Open/create a logfile

@strong{Header file}

@code{#include "libov/ov_logfile.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_logfile_open(
    const OV_STRING   ident,
    OV_STRING         filename,
    OV_STRING         mode
);}
@end format

@strong{Parameters}

@table @code
@item ident

@item filename

@item mode

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_logfile_close(), ov_logfile_logtostdout(), ov_logfile_open(), Logfile
@section Close the logfile

@strong{Header file}

@code{#include "libov/ov_logfile.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT void ov_logfile_close(void);}

@strong{Parameters}

none

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_logfile_logtostdout(), ov_logfile_logtostderr(), ov_logfile_close(), Logfile
@section Log to stdout

@strong{Header file}

@code{#include "libov/ov_logfile.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_logfile_logtostdout(
    const OV_STRING   ident
);}
@end format

@strong{Parameters}

@table @code
@item ident

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_logfile_logtostderr(), ov_logfile_logtontlog(), ov_logfile_logtostdout(), Logfile
@section Log to stderr

@strong{Header file}

@code{#include "libov/ov_logfile.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_logfile_logtostderr(
    const OV_STRING   ident
);}
@end format

@strong{Parameters}

@table @code
@item ident

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_logfile_logtontlog(), ov_logfile_print(), ov_logfile_logtostderr(), Logfile
@section Log to the NT logger (Windows NT only)

@strong{Header file}

@code{#include "libov/ov_logfile.h"}

@strong{Declaration}

@format
@t{#if OV_SYSTEM_NT

OV_DLLFNCEXPORT void ov_logfile_logtontlog(
    const OV_STRING   ident
);

#endif}
@end format

@strong{Parameters}

@table @code
@item ident

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_logfile_print(), ov_logfile_info(), ov_logfile_logtontlog(), Logfile
@section Print text to logfile

@strong{Header file}

@code{#include "libov/ov_logfile.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_logfile_print(
    OV_MSG_TYPE       msgtype,
    const OV_STRING   msg
);}
@end format

@strong{Parameters}

@table @code
@item msgtype

@item msg

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_logfile_info(), ov_logfile_debug(), ov_logfile_print(), Logfile
@section Print info to logfile

@strong{Header file}

@code{#include "libov/ov_logfile.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_logfile_info(
    const OV_STRING   format,
    ...
);}
@end format

@strong{Parameters}

@table @code
@item format

@item ...

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_logfile_debug(), ov_logfile_warning(), ov_logfile_info(), Logfile
@section Print debug info to logfile

@strong{Header file}

@code{#include "libov/ov_logfile.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_logfile_debug(
    const OV_STRING   format,
    ...
);}
@end format

@strong{Parameters}

@table @code
@item format

@item ...

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_logfile_warning(), ov_logfile_error(), ov_logfile_debug(), Logfile
@section Print warning to logfile

@strong{Header file}

@code{#include "libov/ov_logfile.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_logfile_warning(
    const OV_STRING   format,
    ...
);}
@end format

@strong{Parameters}

@table @code
@item format

@item ...

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_logfile_error(), ov_logfile_alert(), ov_logfile_warning(), Logfile
@section Print error to logfile

@strong{Header file}

@code{#include "libov/ov_logfile.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_logfile_error(
    const OV_STRING   format,
    ...
);}
@end format

@strong{Parameters}

@table @code
@item format

@item ...

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_logfile_alert(), ov_logfile_getmessages(), ov_logfile_error(), Logfile
@section Print alert to logfile

@strong{Header file}

@code{#include "libov/ov_logfile.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_logfile_alert(
    const OV_STRING   format,
    ...
);}
@end format

@strong{Parameters}

@table @code
@item format

@item ...

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_logfile_getmessages(), , ov_logfile_alert(), Logfile
@section Get messages from the logfile

@strong{Header file}

@code{#include "libov/ov_logfile.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_logfile_getmessages(
    OV_TIME     *from,
    OV_TIME     *to,
    OV_UINT     max_no_messages,
    OV_STRING   **messages,
    OV_TIME     **times,
    OV_UINT     *no_messages
);}
@end format

@strong{Parameters}

@table @code
@item from

@item to

@item max_no_messages

@item messages

@item times

@item no_messages

@end table

@strong{Return value}

@strong{Remarks}

You must call @code{ov_memstack_lock()} and @code{ov_memstack_unlock()} outside.

@c	------
@c	Malloc
@c	------

@node Malloc, Memstack, Logfile, Top
@chapter Memory management functions for the system heap memory

@menu
* ov_malloc()::    Allocate memory on the heap.
* ov_free()::      Free memory allocated in the heap.
* ov_realloc()::   Reallocate memory on the heap.
* ov_strdup()::    Duplicate a string on the heap using malloc.
@end menu

@c	--------------------------------

@node ov_malloc(), ov_free(), Malloc, Malloc
@section Allocate memory on the heap

@strong{Header file}

@code{#include "libov/ov_malloc.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_POINTER ov_malloc(
    OV_UINT   size
);}
@end format

@strong{Parameters}

@table @code
@item size

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_free(), ov_realloc(), ov_malloc(), Malloc
@section Free memory allocated in the heap

@strong{Header file}

@code{#include "libov/ov_malloc.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_free(
    OV_POINTER   ptr
);}
@end format

@strong{Parameters}

@table @code
@item ptr

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_realloc(), ov_strdup(), ov_free(), Malloc
@section Reallocate memory on the heap

@strong{Header file}

@code{#include "libov/ov_malloc.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_POINTER ov_realloc(
    OV_POINTER   ptr,
    OV_UINT      size
);}
@end format

@strong{Parameters}

@table @code
@item ptr

@item size

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_strdup(), , ov_realloc(), Malloc
@section Duplicate a string on the heap using malloc

@strong{Header file}

@code{#include "libov/ov_malloc.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_STRING ov_strdup(
    OV_STRING   string
);}
@end format

@strong{Parameters}

@table @code
@item string

@end table

@strong{Return value}

@strong{Remarks}

@c	--------
@c	Memstack
@c	--------

@node Memstack, Object, Malloc, Top
@chapter Memory management functions for the memory stack

@menu
* ov_memstack_lock()::     Increment the reference count of the stack and initialize if necessary.
* ov_memstack_alloc()::    Allocate memory on the stack.
* ov_memstack_unlock()::   Decrement the reference count of the stack and free the stack memory if necessary.
@end menu

@c	--------------------------------

@node ov_memstack_lock(), ov_memstack_alloc(), Memstack, Memstack
@section Increment the reference count of the stack and initialize if necessary

@strong{Header file}

@code{#include "libov/ov_memstack.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT void ov_memstack_lock(void);}

@strong{Parameters}

none

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_memstack_alloc(), ov_memstack_unlock(), ov_memstack_lock(), Memstack
@section Allocate memory on the stack

@strong{Header file}

@code{#include "libov/ov_memstack.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_POINTER ov_memstack_alloc(
    OV_UINT   size
);}
@end format

@strong{Parameters}

@table @code
@item size

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_memstack_unlock(), , ov_memstack_alloc(), Memstack
@section Decrement the reference count of the stack and free the stack memory if necessary

@strong{Header file}

@code{#include "libov/ov_memstack.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT void ov_memstack_unlock(void);}

@strong{Parameters}

none

@strong{Return value}

@strong{Remarks}

@c	------
@c	Object
@c	------

@node Object, Operation, Memstack, Top
@chapter Datatypes and functions associated with objects (top level class)

Datatypes associated with objects:

@menu
* OV_FNC_CONSTRUCTOR::         Function prototype for constructor of an object.
* OV_FNC_CHECKINIT::           Function prototype for checking the initialization.
* OV_FNC_DESTRUCTOR::          Function prototype for destructor of an object.
* OV_FNC_STARTUP::             Function prototype for method starting up an object.
* OV_FNC_SHUTDOWN::            Function prototype for method shutting down an object.
* OV_FNC_GETACCESS::           Function prototype for method reading access rights.
* OV_FNC_GETFLAGS::            Function prototype for method reading semantical flags.
* OV_FNC_GETCOMMENT::          Function prototype for method reading comments.
* OV_FNC_GETTECHUNIT::         Function prototype for method reading variable units.
* OV_FNC_GETVAR::              Function prototype for method reading current variable properties.
* OV_FNC_SETVAR::              Function prototype for method writing current variable properties.
@end menu

Functions associated with objects:

@menu
* ov_object_haslinks()::       Test, if an object owns links (except for the parent domain and class).
* ov_object_identifierok()::   Test, if a string is a valid identifier for an object.
@end menu

@c	--------------------------------

@node OV_FNC_CONSTRUCTOR, OV_FNC_CHECKINIT, Object, Object
@section Function prototype for constructor of an object

The function prototype @code{OV_FNC_CONSTRUCTOR} is used for defining the constructor
function of an object, which is called during instantiation of an object using the
function @code{ov_class_createobject()}. If the function does not return @code{OV_ERR_OK}
the object is destroyed immediately and no object is created.

@strong{Header file}

@code{#include "ov.ovf"}

@strong{Declaration}

@format
@t{typedef OV_RESULT OV_FNC_CONSTRUCTOR(
    OV_INSTPTR_ov_object pobj
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the object to be constructed.
@end table

@strong{Return value}

Functions of this type must return @code{OV_ERR_OK} if the construction succeeds 
or an error code otherwise.

@c	--------------------------------

@node OV_FNC_CHECKINIT, OV_FNC_DESTRUCTOR, OV_FNC_CONSTRUCTOR, Object
@section Function prototype for checking the initialization

The function prototype @code{OV_FNC_CHECKINIT} is used for defining a function of an
object, which checks if the initialization resulted in a valid state of the object.
This function is called during instantiation of an object using the function
@code{ov_class_createobject()}. If the function does not return @code{OV_ERR_OK}
the object is destroyed immediately and no object is created.

@strong{Header file}

@code{#include "ov.ovf"}

@strong{Declaration}

@format
@t{typedef OV_RESULT OV_FNC_CHECKINIT(
    OV_INSTPTR_ov_object pobj
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the object of which the initialization is checked.
@end table

@strong{Return value}

Functions of this type must return @code{OV_ERR_OK} if the initialzation was valid
or an error code otherwise.

@c	--------------------------------

@node OV_FNC_DESTRUCTOR, OV_FNC_STARTUP, OV_FNC_CHECKINIT, Object
@section Function prototype for destructor of an object

The function prototype @code{OV_FNC_DESTRUCTOR} is used for defining the destructor
function of an object, which is called during deletion of an object using the
function @code{ov_class_deleteobject()}.

@strong{Header file}

@code{#include "ov.ovf"}

@strong{Declaration}

@format
@t{typedef void OV_FNC_DESTRUCTOR(
    OV_INSTPTR_ov_object pobj
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the object to be destructed.
@end table

@strong{Return value}

none.

@c	--------------------------------

@node OV_FNC_STARTUP, OV_FNC_SHUTDOWN, OV_FNC_DESTRUCTOR, Object
@section Function prototype for method starting up an object

The function prototype @code{OV_FNC_STARTUP} is used for defining the function of an
object, which is called when the object is started up, either at system startup or
immediately after construction (instantiation) of the object.

@strong{Header file}

@code{#include "ov.ovf"}

@strong{Declaration}

@format
@t{typedef void OV_FNC_STARTUP(
    OV_INSTPTR_ov_object pobj
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the object to be started up.
@end table

@strong{Return value}

none.

@c	--------------------------------

@node OV_FNC_SHUTDOWN, OV_FNC_GETACCESS, OV_FNC_STARTUP, Object
@section Function prototype for method shutting down an object

The function prototype @code{OV_FNC_SHUTDOWN} is used for defining the function of an
object, which is called when the object is shut down, either at system shutdown or
immediately before destruction (deletion) of the object.

@strong{Header file}

@code{#include "ov.ovf"}

@strong{Declaration}

@format
@t{typedef void OV_FNC_SHUTDOWN(
    OV_INSTPTR_ov_object pobj
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the object to be shut down.
@end table

@strong{Return value}

none.

@c	--------------------------------

@node OV_FNC_GETACCESS, OV_FNC_GETFLAGS, OV_FNC_SHUTDOWN, Object
@section Function prototype for method reading access rights

The function prototype @code{OV_FNC_GETACCESS} is used for defining the function
of an object, which returns the access rights of an object or one of its elements.

@strong{Header file}

@code{#include "ov.ovf"}

@strong{Declaration}

@format
@t{typedef OV_ACCESS OV_FNC_GETACCESS(
    OV_INSTPTR_ov_object pobj,
    const OV_ELEMENT     *pelem,
    const OV_TICKET      *pticket
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the object to be asked about the access rights.
@item @code{pelem}
Pointer to a structure containing information about the element of the object
the access rights are read from.
@item @code{pticket}
Pointer to the ticket structure providing authentification/verification
information. The information included in this structure may be used to
decide which access rights are granted to the specified element of the
object.
@end table

@strong{Return value}

Access rights of the object or object element respectively.

@c	--------------------------------

@node OV_FNC_GETFLAGS, OV_FNC_GETCOMMENT, OV_FNC_GETACCESS, Object
@section Function prototype for method reading semantical flags

The function prototype @code{OV_FNC_GETFLAGS} is used for defining the function
of an object, which returns the semantic flags of an object or one of its elements.

@strong{Header file}

@code{#include "ov.ovf"}

@strong{Declaration}

@format
@t{typedef OV_UINT OV_FNC_GETFLAGS(
    OV_INSTPTR_ov_object pobj,
    const OV_ELEMENT     *pelem
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the object to be asked about the semantic flags.
@item @code{pelem}
Pointer to a structure containing information about the element of the object
the semantic flags are read from.
@end table

@strong{Return value}

Semantic flags of the object or object element respectively.

@c	--------------------------------

@node OV_FNC_GETCOMMENT, OV_FNC_GETTECHUNIT, OV_FNC_GETFLAGS, Object
@section Function prototype for method reading comments

The function prototype @code{OV_FNC_GETCOMMENT} is used for defining the function
of an object, which returns the comment associated with an object or one of its elements.

@strong{Header file}

@code{#include "ov.ovf"}

@strong{Declaration}

@format
@t{typedef OV_STRING OV_FNC_GETCOMMENT(
    OV_INSTPTR_ov_object pobj,
    const OV_ELEMENT     *pelem
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the object to be asked about the associated comment.
@item @code{pelem}
Pointer to a structure containing information about the element of the object
the comment to be read is associated with.
@end table

@strong{Return value}

Comment associated with the object or object element respectively.

@c	--------------------------------

@node OV_FNC_GETTECHUNIT, OV_FNC_GETVAR, OV_FNC_GETCOMMENT, Object
@section Function prototype for method reading variable units

The function prototype @code{OV_FNC_GETACCESS} is used for defining the function
of an object, which returns the technical unit of a variable element of the object.

@strong{Header file}

@code{#include "ov.ovf"}

@strong{Declaration}

@format
@t{typedef OV_STRING OV_FNC_GETTECHUNIT(
    OV_INSTPTR_ov_object pobj,
    const OV_ELEMENT     *pelem
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the object to be asked about the technical unit.
@item @code{pelem}
Pointer to a structure containing information about the variable element of the object
the comment is read from.
@end table

@strong{Return value}

Technical unit associated with the variable element of the object.

@c	--------------------------------

@node OV_FNC_GETVAR, OV_FNC_SETVAR, OV_FNC_GETTECHUNIT, Object
@section Function prototype for method reading current variable properties

The function prototype @code{OV_FNC_GETVAR} is used for defining the function
of an object, which reads the current properties of a variable of the object.

@strong{Header file}

@code{#include "ov.ovf"}

@strong{Declaration}

@format
@t{typedef OV_RESULT OV_FNC_GETVAR(
    OV_INSTPTR_ov_object pobj,
    const OV_ELEMENT     *pelem,
    OV_ANY               *pvarcurrprops
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the object containing the variable element to be read.
@item @code{pelem}
Pointer to a structure containing information about the variable element of the object
the current properties are read from.
@item @code{pvarcurrprops}
Pointer to a structure containing the current properties of the variable. This
structure has to be filled by the function when reading the current properties
succeeds.
@end table

@strong{Return value}

Functions of this type must return @code{OV_ERR_OK} if reading the current properties
of the variable succeeds or an error code otherwise.

@c	--------------------------------

@node OV_FNC_SETVAR, ov_object_haslinks(), OV_FNC_GETVAR, Object
@section Function prototype for method writing current variable properties

The function prototype @code{OV_FNC_SETVAR} is used for defining the function
of an object, which sets the current properties of a variable of the object.

@strong{Header file}

@code{#include "ov.ovf"}

@strong{Declaration}

@format
@t{typedef OV_RESULT OV_FNC_SETVAR(
    OV_INSTPTR_ov_object pobj,
    const OV_ELEMENT     *pelem
    const OV_ANY         *pvarcurrprops
);}
@end format

@strong{Parameters}

@table @code
@item @code{pobj}
Pointer to the object containing the variable element to be set.
@item @code{pelem}
Pointer to a structure containing information about the variable element of the object
of which the current properties are set.
@item @code{pvarcurrprops}
Pointer to a structure containing the current properties of the variable which the
object is asked to set.
@end table

@strong{Return value}

Functions of this type must return @code{OV_ERR_OK} if setting the current properties
of the variable succeeds or an error code otherwise. You should use @code{OV_ERR_BADVALUE}
to indicate that the variable value is not accepted (e.g. out of bounds) and
@code{OV_ERR_BADTYPE} to indicate that the given variable type is not accepted by
the object.

@c	--------------------------------

@node ov_object_haslinks(), ov_object_identifierok(), OV_FNC_SETVAR, Object
@section Test, if an object owns links (except for the parent domain and class)

@strong{Header file}

@code{#include "libov/ov_object.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_BOOL ov_object_haslinks(
    OV_INSTPTR_ov_object   pobj
);}
@end format

@strong{Parameters}

@table @code
@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_object_identifierok(), , ov_object_haslinks(), Object
@section Test, if a string is a valid identifier for an object

@strong{Header file}

@code{#include "libov/ov_object.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_BOOL ov_object_identifierok(
    OV_STRING   identifier
);
}
@end format

@strong{Parameters}

@table @code
@item identifier

@end table

@strong{Return value}

@strong{Remarks}

@c  ---------
@c  Operation
@c  ---------

@node Operation, Part, Object, Top
@chapter Functions associated with operations

@menu
* ov_operation_load()::        Load an operation into the database.
* ov_operation_compare()::     Compare an operation with its definition.
* ov_operation_canunload()::   Test if we can unload an operation from the database.
@end menu

@c	--------------------------------

@node ov_operation_load(), ov_operation_compare(), Operation, Operation
@section Load an operation into the database

@strong{Header file}

@code{#include "libov/ov_operation.h"}

@strong{Declaration}

@format
@t{OV_RESULT ov_operation_load(
    OV_OPERATION_DEF       *popdef,
    OV_INSTPTR_ov_domain   pparent
);}
@end format

@strong{Parameters}

@table @code
@item popdef

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_operation_compare(), ov_operation_canunload(), ov_operation_load(), Operation
@section Compare an operation with its definition

@strong{Header file}

@code{#include "libov/ov_operation.h"}

@strong{Declaration}

@format
@t{OV_RESULT ov_operation_compare(
    OV_INSTPTR_ov_operation   pop,
    OV_OPERATION_DEF          *popdef
);}
@end format

@strong{Parameters}

@table @code
@item pop

@item popdef

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_operation_canunload(), , ov_operation_compare(), Operation
@section Test if we can unload an operation from the database

@strong{Header file}

@code{#include "libov/ov_operation.h"}

@strong{Declaration}

@format
@t{OV_BOOL ov_operation_canunload(
    OV_INSTPTR_ov_operation   pop
);}
@end format

@strong{Parameters}

@table @code
@item pop

@end table

@strong{Return value}

@strong{Remarks}

@c  ----
@c  Part
@c  ----

@node Part, Path, Operation, Top
@chapter Functions associated with parts

@menu
* ov_part_load()::        Load a part into the database.
* ov_part_compare()::     Compare a part with its definition.
* ov_part_canunload()::   Test if we can unload a part from the database.
@end menu

@c	--------------------------------

@node ov_part_load(), ov_part_compare(), Part, Part
@section Load a part into the database

@strong{Header file}

@code{#include "libov/ov_part.h"}

@strong{Declaration}

@format
@t{OV_RESULT ov_part_load(
    OV_PART_DEF            *ppartdef,
    OV_INSTPTR_ov_domain   pparent
);}
@end format

@strong{Parameters}

@table @code
@item ppartdef

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_part_compare(), ov_part_canunload(), ov_part_load(), Part
@section Compare a part with its definition

@strong{Header file}

@code{#include "libov/ov_part.h"}

@strong{Declaration}

@format
@t{OV_RESULT ov_part_compare(
    OV_INSTPTR_ov_part   ppart,
    OV_PART_DEF          *ppartdef
);}
@end format

@strong{Parameters}

@table @code
@item ppart

@item ppartdef

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_part_canunload(), , ov_part_compare(), Part
@section Test if we can unload a part from the database

@strong{Header file}

@code{#include "libov/ov_part.h"}

@strong{Declaration}

@format
@t{OV_BOOL ov_part_canunload(
    OV_INSTPTR_ov_part   ppart
);}
@end format

@strong{Parameters}

@table @code
@item ppart

@end table

@strong{Return value}

@strong{Remarks}

@c	----
@c	Path
@c	----

@node Path, Result, Part, Top
@chapter Datatypes and functions associated with paths

Datatypes associated with paths:

@menu
* OV_PATH::                      Array of elements corresponding to the identifiers of a path name.
@end menu

Functions associated with paths:

@menu
* ov_path_resolve()::            Resolve a path using a given path name.
* ov_path_getcanonicalpath()::   Get the canonical path of an element.
* ov_path_getobjectpointer()::   Get the pointer to an object with given path name.
@end menu

@c	--------------------------------

@node OV_PATH, ov_path_resolve(), Path, Path
@section Array of elements corresponding to the identifiers of a path name

@strong{Header file}

@code{#include "libov/ov_path.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_UINT      size;            /* number of path elements */
    OV_ELEMENT   *elements;       /* pointer to array of elements */
@}   OV_PATH;}
@end format

@strong{Remarks}

@c	--------------------------------

@node ov_path_resolve(), ov_path_getcanonicalpath(), OV_PATH, Path
@section Resolve a path using a given path name

@strong{Header file}

@code{#include "libov/ov_path.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_path_resolve(
    OV_PATH           *ppath,
    const OV_PATH     *prelpath,
    const OV_STRING   pathname,
    const OV_UINT     version
);}
@end format

@strong{Parameters}

@table @code
@item ppath

@item prelpath

@item pathname

@item version

@end table

@strong{Return value}

@strong{Remarks}

The memory for the path elements is allocated on the memory stack, use @code{ov_memstack_lock()}/@code{unlock()} outside
of this function.

@c	--------------------------------

@node ov_path_getcanonicalpath(), ov_path_getobjectpointer(), ov_path_resolve(), Path
@section Get the canonical path of an element

@strong{Header file}

@code{#include "libov/ov_path.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_STRING ov_path_getcanonicalpath(
    OV_INSTPTR_ov_object   pobj,
    const OV_UINT          version
);}
@end format

@strong{Parameters}

@table @code
@item pobj

@item version

@end table

@strong{Return value}

@strong{Remarks}

The memory for the path name is allocated on the memory stack, use @code{ov_memstack_lock()}/@code{unlock()}outside
of this function.

@c	--------------------------------

@node ov_path_getobjectpointer(), , ov_path_getcanonicalpath(), Path
@section Get the pointer to an object with given path name

@strong{Header file}

@code{#include "libov/ov_path.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_INSTPTR_ov_object ov_path_getobjectpointer(
    const OV_STRING   pathname,
    const OV_UINT     version
);}
@end format

@strong{Parameters}

@table @code
@item pathname

@item version

@end table

@strong{Return value}

@strong{Remarks}

You need @emph{not} call @code{ov_memstack_lock()}/@code{unlock()} outside of this function.

@c	------
@c	Result
@c	------

@node Result, Scheduler, Path, Top
@chapter Functions associated with results of function calls

@menu
* ov_result_getresulttext()::   Return error string associated with an error code.
@end menu

@c	--------------------------------

@node ov_result_getresulttext(), , Result, Result
@section Return error string associated with an error code

@strong{Header file}

@code{#include "libov/ov_result.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_STRING ov_result_getresulttext(
    OV_RESULT   result
);}
@end format

@strong{Parameters}

@table @code
@item result

@end table

@strong{Return value}

@strong{Remarks}

@c	---------
@c	Scheduler
@c	---------

@node Scheduler, String, Result, Top
@chapter Datatypes and functions associated with the scheduler

Datatypes associated with the scheduler:

@menu
* OV_FNC_EXECUTE::                     Function prototype for methods used in active objects.
* OV_SCHEDULER_EVENT::                 Event in a simple event queue, ordered by time.
@end menu

Functions associated with the scheduler:

@menu
* ov_scheduler_register()::            Register an active object with the scheduler.
* ov_scheduler_unregister()::          Unregister an active object with the scheduler.
* ov_scheduler_setabseventtime()::     Set absolute event time of a registered active object.
* ov_scheduler_setreleventtime()::     Set relative event time of a registered active object (time span from now on).
* ov_scheduler_schedulenextevent()::   Schedule the next event of the event queue if the event is pending.
@end menu

@c	--------------------------------

@node OV_FNC_EXECUTE, OV_SCHEDULER_EVENT, Scheduler, Scheduler
@section Function prototype for methods used in active objects

@strong{Header file}

@code{#include "libov/ov_scheduler.h"}

@strong{Declaration}

@format
@t{typedef void OV_FNC_EXECUTE(
    OV_INSTPTR_ov_object   pobj
);}
@end format

@strong{Parameters}

@table @code
@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node OV_SCHEDULER_EVENT, ov_scheduler_register(), OV_FNC_EXECUTE, Scheduler
@section Event in a simple event queue, ordered by time

@strong{Header file}

@code{#include "libov/ov_scheduler.h"}

@strong{Declaration}

@format
@t{struct OV_SCHEDULER_EVENT @{
    struct OV_SCHEDULER_EVENT   *pnext;            /* Pointer to next scheduled event */
    OV_INSTPTR_ov_object        pobj;              /* Pointer to scheduled active object */
    OV_FNC_EXECUTE              *executefnc;       /* method to call on active object */
    OV_TIME                     time;              /* time of this scheduled event */
@};

typedef struct OV_SCHEDULER_EVENT   OV_SCHEDULER_EVENT; }
@end format

@strong{Remarks}

@c	--------------------------------

@node ov_scheduler_register(), ov_scheduler_unregister(), OV_SCHEDULER_EVENT, Scheduler
@section Register an active object with the scheduler

@strong{Header file}

@code{#include "libov/ov_scheduler.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_scheduler_register(
    OV_INSTPTR_ov_object   pobj,
    OV_FNC_EXECUTE         *executefnc
);}
@end format

@strong{Parameters}

@table @code
@item pobj

@item executefnc

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_scheduler_unregister(), ov_scheduler_setabseventtime(), ov_scheduler_register(), Scheduler
@section Unregister an active object with the scheduler

@strong{Header file}

@code{#include "libov/ov_scheduler.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_scheduler_unregister(
    OV_INSTPTR_ov_object   pobj
);}
@end format

@strong{Parameters}

@table @code
@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_scheduler_setabseventtime(), ov_scheduler_setreleventtime(), ov_scheduler_unregister(), Scheduler
@section Set absolute event time of a registered active object

@strong{Header file}

@code{#include "libov/ov_scheduler.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_scheduler_setabseventtime(
    OV_INSTPTR_ov_object   pobj,
    OV_TIME                *ptime
);}
@end format

@strong{Parameters}

@table @code
@item pobj

@item ptime

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_scheduler_setreleventtime(), ov_scheduler_schedulenextevent(), ov_scheduler_setabseventtime(), Scheduler
@section Set relative event time of a registered active object (time span from now on)

@strong{Header file}

@code{#include "libov/ov_scheduler.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_scheduler_setreleventtime(
    OV_INSTPTR_ov_object   pobj,
    OV_TIME_SPAN           *ptimespan
);}
@end format

@strong{Parameters}

@table @code
@item pobj

@item ptimespan

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_scheduler_schedulenextevent(), , ov_scheduler_setreleventtime(), Scheduler
@section Schedule the next event of the event queue if the event is pending

@strong{Header file}

@code{#include "libov/ov_scheduler.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT OV_TIME_SPAN *ov_scheduler_schedulenextevent(void);}

@strong{Parameters}

none

@strong{Return value}

@strong{Remarks}

@c	------
@c	String
@c	------

@node String, Structure, Scheduler, Top
@chapter Functions associated with string variables

@menu
* ov_string_setvalue()::      Set value of a string in the database.
* ov_string_setvecvalue()::   Set value of a string vector in the database.
* ov_string_compare()::       Compare two strings.
* ov_string_getlength()::     Get the length of a string.
* ov_string_append()::        Append a string to an existing one.
* ov_string_print()::         Formatted print to a string.
* ov_string_match()::         Test if a string matches a regular expression.
* ov_string_tolower()::       Convert a string to lower case.
* ov_string_toupper()::       Convert a string to upper case.
@end menu

@c	--------------------------------

@node ov_string_setvalue(), ov_string_setvecvalue(), String, String
@section Set value of a string in the database

@strong{Header file}

@code{#include "libov/ov_string.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_string_setvalue(
    OV_STRING         *pstring,
    const OV_STRING   value
);}
@end format

@strong{Parameters}

@table @code
@item pstring

@item value

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_string_setvecvalue(), ov_string_compare(), ov_string_setvalue(), String
@section Set value of a string vector in the database

@strong{Header file}

@code{#include "libov/ov_string.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_string_setvecvalue(
    OV_STRING         *pstringvec,
    const OV_STRING   *pvalue,
    OV_UINT           veclen
);}
@end format

@strong{Parameters}

@table @code
@item pstringvec

@item pvalue

@item veclen

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_string_compare(), ov_string_getlength(), ov_string_setvecvalue(), String
@section Compare two strings, result is greater than, equal to or less than zero

@strong{Header file}

@code{#include "libov/ov_string.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_INT ov_string_compare(
    const OV_STRING   string1,
    const OV_STRING   string2
);}
@end format

@strong{Parameters}

@table @code
@item string1

@item string2

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_string_getlength(), ov_string_append(), ov_string_compare(), String
@section Get the length of a string

@strong{Header file}

@code{#include "libov/ov_string.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_UINT ov_string_getlength(
    const OV_STRING   string
);}
@end format

@strong{Parameters}

@table @code
@item string

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_string_append(), ov_string_print(), ov_string_getlength(), String
@section Append a string to an existing one

@strong{Header file}

@code{#include "libov/ov_string.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_string_append(
    OV_STRING         *pstring,
    const OV_STRING   appstring
);}
@end format

@strong{Parameters}

@table @code
@item pstring

@item appstring

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_string_print(), ov_string_match(), ov_string_append(), String
@section Formatted print to a string

@strong{Header file}

@code{#include "libov/ov_string.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_string_print(
    OV_STRING         *pstring,
    const OV_STRING   format,
    ...
);}
@end format

@strong{Parameters}

@table @code
@item pstring

@item format

@item ...

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_string_match(), ov_string_tolower(), ov_string_print(), String
@section Test if a string matches a regular expression

@strong{Header file}

@code{#include "libov/ov_string.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_BOOL ov_string_match(
    const OV_STRING   string,
    const OV_STRING   mask
);}
@end format

@strong{Parameters}

@table @code
@item string

@item mask

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_string_tolower(), ov_string_toupper(), ov_string_match(), String
@section Convert a string to lower case

@strong{Header file}

@code{#include "libov/ov_string.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_STRING ov_string_tolower(
    const OV_STRING   string
);}
@end format

@strong{Parameters}

@table @code
@item string

@end table

@strong{Return value}

@strong{Remarks}

You must call @code{ov_memstack_lock}/@code{unlock()} outside of this function!

@c	--------------------------------

@node ov_string_toupper(), , ov_string_tolower(), String
@section Convert a string to upper case

@strong{Header file}

@code{#include "libov/ov_string.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_STRING ov_string_toupper(
   const OV_STRING   string
);}
@end format

@strong{Parameters}

@table @code
@item string

@end table

@strong{Return value}

@strong{Remarks}

You must call @code{ov_memstack_lock}/@code{unlock()} outside of this function!

@c  ---------
@c  Structure
@c  ---------

@node Structure, Supervise, String, Top
@chapter Functions associated with Structures

@menu
* ov_structure_search()::      Search for a structure object with given identifier.
* ov_structure_load()::        Load a structure into the database.
* ov_structure_compare()::     Compare a structure with its definition.
* ov_structure_canunload()::   Test if we can unload a structure from the database.
@end menu

@c	--------------------------------

@node ov_structure_search(), ov_structure_load(), Structure, Structure
@section Search for a structure object with given identifier

@strong{Header file}

@code{#include "libov/ov_structure.h"}

@strong{Declaration}

@format
@t{OV_INSTPTR_ov_structure ov_structure_search(
    OV_STRING   identifier
);}
@end format

@strong{Parameters}

@table @code
@item identifier

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_structure_load(), ov_structure_compare(), ov_structure_search(), Structure
@section Load a structure into the database

@strong{Header file}

@code{#include "libov/ov_structure.h"}

@strong{Declaration}

@format
@t{OV_RESULT ov_structure_load(
    OV_STRUCTURE_DEF       *pstructdef,
    OV_INSTPTR_ov_domain   pparent
);}
@end format

@strong{Parameters}

@table @code
@item pstructdef

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_structure_compare(), ov_structure_canunload(), ov_structure_load(), Structure
@section Compare a structure with its definition

@strong{Header file}

@code{#include "libov/ov_structure.h"}

@strong{Declaration}

@format
@t{OV_RESULT ov_structure_compare(
    OV_INSTPTR_ov_structure   pstruct,
    OV_STRUCTURE_DEF          *pstructdef
);}
@end format

@strong{Parameters}

@table @code
@item pstruct

@item pstructdef

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_structure_canunload(), , ov_structure_compare(), Structure
@section Test if we can unload a structure from the database

@strong{Header file}

@code{#include "libov/ov_structure.h"}

@strong{Declaration}

@format
@t{OV_BOOL ov_structure_canunload(
    OV_INSTPTR_ov_structure   pstruct
);}
@end format

@strong{Parameters}

@table @code
@item pstruct

@end table

@strong{Return value}

@strong{Remarks}

@c	---------
@c	Supervise
@c	---------

@node Supervise, Time, Structure, Top
@chapter Execution time supervision functions

The purpose of these functions is to supervise the duration of execution of methods implemented by the user.
Using this mechanism, the duration of execution of a certain function is limited to a certain value, which may
be freely chosen. Before the function is actually called, a timer is started with the duration limit as timeout.
Then the function is called. If the timer does not time out during the function call, the timer will be stopped and
nothing else happens. But if there is a timeout, the function will be aborted by brute force and the function will
return immediately. Note that this may have side effects!

@strong{Attention:}
@itemize @bullet
@item
The supervision code is @emph{not reentrant}. If you call @code{ov_supervise_start()} while the supervision mechanism
is already running, you will get an error.

@item
Under certain circumstances variables of the function calling the supervision functions have to be declared as volatile,
because they may be optimized away when the @code{longjmp()} function is called.

@item
Under Windows NT each call of the supervise routines has to come from the @emph{same thread}.
@end itemize

@strong{Resources used:}
@itemize @bullet
@item
Unix: @code{ITIMER_REAL} and @code{SIGALRM}

@item
NT: an invisible timer window
@end itemize

@strong{Side effects:}
Currently unknown -- it seems to work, but you should @emph{not rely on it}.

@menu
* Example code::            for the execution time supervision functions.
@end menu

Datatypes:

@menu
* OV_JUMPBUFFER::           Datatype describing the stack frame before calling the user function.
@end menu

Functions:

@menu
* ov_supervise_setjmp()::   Wrapper macro for the setjmp function/macro.
* ov_supervise_start()::    Start the supervision of a user function.
* ov_supervise_end()::      Finish supervising a user function.
@end menu

@c	--------------------------------

@node Example code, OV_JUMPBUFFER, Supervise, Supervise
@section Example code for the execution time supervision functions

@format
@t{#include "libov/ov_supervise.h"

OV_TIME_SPAN    timeout;
OV_JUMPBUFFER   jumpbuffer;
timeout.secs = 1;
timeout.usecs = 500000;
if(ov_supervise_setjmp(jumpbuffer) == 0) @{
    if(!ov_supervise_start(&timeout, &jumpbuffer)) @{
        /* error in ov_supervise_start(), e.g. could not start timer */
        printf("error\n");
    @}	
    userfunction(); /* call of the user's function */
    if(!ov_supervise_end()) @{
        /* error in ov_supervise_end() */
        printf("error\n");
    @}
@} else @{
    /* timer timed out, here's code handling this error */
    printf("userfunction() aborted\n");
@}}
@end format

@c	--------------------------------

@node OV_JUMPBUFFER, ov_supervise_setjmp(), Example code, Supervise
@section Datatype describing the stack frame before calling the user function

This datatype describes the stack frame before calling the user function and allows to abort it.

@strong{Header file}

@code{#include "libov/ov_supervise.h"}

@strong{Declaration}

@format
@t{#if OV_SYSTEM_UNIX
typedef sigjmp_buf   OV_JUMPBUFFER;
#else
typedef jmp_buf      OV_JUMPBUFFER;
#endif}
@end format

@strong{Remarks}

@c	--------------------------------

@node ov_supervise_setjmp(), ov_supervise_start(), OV_JUMPBUFFER, Supervise
@section Wrapper macro for the setjmp function/macro

@strong{Header file}

@code{#include "libov/ov_supervise.h"}

@strong{Macro usage}

@code{ov_supervise_setjmp(jumpbuffer);}

@strong{Parameters}

@table @code
@item jumpbuffer

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_supervise_start(), ov_supervise_end(), ov_supervise_setjmp(), Supervise
@section Start the supervision of a user function

@strong{Header file}

@code{#include "libov/ov_supervise.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_BOOL ov_supervise_start(
    OV_TIME_SPAN    *ptimeout,
    OV_JUMPBUFFER   *pjumpbuffer
);}
@end format

@strong{Parameters}

@table @code
@item ptimeout

@item pjumpbuffer

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_supervise_end(), , ov_supervise_start(), Supervise
@section Finish supervising a user function

@strong{Header file}

@code{#include "libov/ov_supervise.h"}

@strong{Declaration}

@code{OV_DLLFNCEXPORT OV_BOOL ov_supervise_end(void);}

@strong{Parameters}

none

@strong{Return value}

@strong{Remarks}

@c	----
@c	Time
@c	----

@node Time, Variable, Supervise, Top
@chapter Functions associated with time variables

@menu
* ov_time_gettime()::       Get the current system time.
* ov_time_add()::           Calculate the sum of a time and a time span.
* ov_time_diff()::          Calculate the difference of two times.
* ov_time_compare()::       Compare two times.
* ov_time_timetoascii()::   Convert a time into an ASCII string.
* ov_time_asciitotime()::   Convert an ASCII string into a time.
@end menu

@c	--------------------------------

@node ov_time_gettime(), ov_time_add(), Time, Time
@section Get the current system time

@strong{Header file}

@code{#include "libov/ov_time.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_time_gettime(
    OV_TIME   *ptime
);}
@end format

@strong{Parameters}

@table @code
@item ptime

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_time_add(), ov_time_diff(), ov_time_gettime(), Time
@section Calculate the sum of a time and a time span

@strong{Header file}

@code{#include "libov/ov_time.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_time_add(
    OV_TIME              *psum,
    const OV_TIME        *padd1,
    const OV_TIME_SPAN   *padd2
);}
@end format

@strong{Parameters}

@table @code
@item psum

@item padd1

@item padd2

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_time_diff(), ov_time_compare(), ov_time_add(), Time
@section Calculate the difference of two times

@strong{Header file}

@code{#include "libov/ov_time.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_time_diff(
    OV_TIME_SPAN    *pdiff,
    const OV_TIME   *psub1,
    const OV_TIME   *psub2
);}
@end format

@strong{Parameters}

@table @code
@item pdiff

@item psub1

@item psub2

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_time_compare(), ov_time_timetoascii(), ov_time_diff(), Time
@section Compare two times, result is -1, 0 or 1

@strong{Header file}

@code{#include "libov/ov_time.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_INT ov_time_compare(
    const OV_TIME   *ptime1,
    const OV_TIME   *ptime2
);}
@end format

@strong{Parameters}

@table @code
@item ptime1

@item ptime2

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_time_timetoascii(), ov_time_asciitotime(), ov_time_compare(), Time
@section Convert a time into an ASCII string

@strong{Header file}

@code{#include "libov/ov_time.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_STRING ov_time_timetoascii(
    const OV_TIME   *ptime
);}
@end format

@strong{Parameters}

@table @code
@item ptime

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_time_asciitotime(), , ov_time_timetoascii(), Time
@section Convert an ASCII string into a time

@strong{Header file}

@code{#include "libov/ov_time.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_time_asciitotime(
    OV_TIME           *ptime,
    const OV_STRING   timestring
);}
@end format

@strong{Parameters}

@table @code
@item ptime

@item timestring

@end table

@strong{Return value}

@strong{Remarks}

@c  --------
@c  Variable
@c  --------

@node Variable, Vector, Time, Top
@chapter Functions associated with variables

@menu
* ov_variable_load()::        Load a variable into the database.
* ov_variable_compare()::     Compare a variable with its definition.
* ov_variable_canunload()::   Test if we can unload a variable from the database.
@end menu

@c	--------------------------------

@node ov_variable_load(), ov_variable_compare(), Variable, Variable
@section Load a variable into the database

@strong{Header file}

@code{#include "libov/ov_variable.h"}

@strong{Declaration}

@format
@t{OV_RESULT ov_variable_load(
    OV_VARIABLE_DEF        *pvardef,
    OV_INSTPTR_ov_domain   pparent
);}
@end format

@strong{Parameters}

@table @code
@item pvardef

@item pparent

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_variable_compare(), ov_variable_canunload(), ov_variable_load(), Variable
@section Compare a variable with its definition

@strong{Header file}

@code{#include "libov/ov_variable.h"}

@strong{Declaration}

@format
@t{OV_RESULT ov_variable_compare(
    OV_INSTPTR_ov_variable   pvar,
    OV_VARIABLE_DEF          *pvardef
);}
@end format

@strong{Parameters}

@table @code
@item pvar

@item pvardef

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_variable_canunload(), , ov_variable_compare(), Variable
@section Test if we can unload a variable from the database

@strong{Header file}

@code{#include "libov/ov_variable.h"}

@strong{Declaration}

@format
@t{OV_BOOL ov_variable_canunload(
    OV_INSTPTR_ov_variable   pvar
);}
@end format

@strong{Parameters}

@table @code
@item pvar

@end table

@strong{Return value}

@strong{Remarks}

@c  ------
@c  Vector
@c  ------

@node Vector, Vendortree, Variable, Top
@chapter Functions associated with vector variables

@menu
* ov_vector_setstaticvalue()::     Set the value of a static vector variable.
* ov_vector_setdynamicvalue()::    Set the value of a dynamic vector variable.
* ov_vector_setdynamicveclen()::   Set the vector length of a dynamic vector variable value.
* ov_vector_compare()::            Compare two vector variable values.
@end menu

@c	--------------------------------

@node ov_vector_setstaticvalue(), ov_vector_setdynamicvalue(), Vector, Vector
@section Set the value of a static vector variable

@strong{Header file}

@code{#include "libov/ov_vector.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vector_setstaticvalue(
    OV_POINTER          pvector,
    const OV_POINTER    pvalue,
    const OV_UINT       veclen,
    const OV_UINT       size,
    const OV_VAR_TYPE   vartype
);}
@end format

@strong{Parameters}

@table @code
@item pvector

@item pvalue

@item veclen

@item size

@item vartype

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vector_setdynamicvalue(), ov_vector_setdynamicveclen(), ov_vector_setstaticvalue(), Vector
@section Set the value of a dynamic vector variable

@strong{Header file}

@code{#include "libov/ov_vector.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vector_setdynamicvalue(
    OV_GENERIC_VEC      *pvector,
    const OV_POINTER    pvalue,
    const OV_UINT       veclen,
    const OV_UINT       size,
    const OV_VAR_TYPE   vartype
);}
@end format

@strong{Parameters}

@table @code
@item pvector

@item pvalue

@item veclen

@item size

@item vartype

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vector_setdynamicveclen(), ov_vector_compare(), ov_vector_setdynamicvalue(), Vector
@section Set the vector length of a dynamic vector variable value

@strong{Header file}

@code{#include "libov/ov_vector.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vector_setdynamicveclen(
    OV_GENERIC_VEC      *pvector,
    const OV_UINT       veclen,
    const OV_UINT       size,
    const OV_VAR_TYPE   vartype
);}
@end format

@strong{Parameters}

@table @code
@item pvector

@item veclen

@item size

@item vartype

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vector_compare(), , ov_vector_setdynamicveclen(), Vector
@section Compare two vector variable values, result is greater than, equal to or less than zero

@strong{Header file}

@code{#include "libov/ov_vector.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_INT ov_vector_compare(
    const OV_POINTER    pvalue1,
    const OV_POINTER    pvalue2,
    const OV_UINT       veclen,
    const OV_UINT       size,
    const OV_VAR_TYPE   vartype
);}
@end format

@strong{Parameters}

@table @code
@item pvalue1

@item pvalue2

@item veclen

@item size

@item vartype

@end table

@strong{Return value}

@strong{Remarks}

@c	----------
@c	Vendortree
@c	----------

@node Vendortree, , Vector, Top
@chapter Datatypes and functions associated with the vendor tree

Datatypes associated with the vendor tree:

@menu
* OV_FNC_GETVENDORVAR::                    Function prototype for getting vendor variables.
* OV_VENDORTREE_INFO::                     Information of a vendor tree object.
@end menu

Functions associated with the vendor tree:

@menu
* ov_vendortree_init()::                   Initialize the vendor tree.
* ov_vendortree_getunit()::                Get unit of a vendor object.
* ov_vendortree_getvar()::                 Get variable of a vendor object.
* ov_vendortree_setdatabasename()::        Set database name.
* ov_vendortree_setname()::                Set vendor name.
* ov_vendortree_setsemanticflag()::        Set semantic flag.
* ov_vendortree_setservername()::          Set server name.
* ov_vendortree_setserverdescription()::   Set server description.
* ov_vendortree_setserverversion()::       Set server version.
* ov_vendortree_setstartuptime()::         Set startup time.
* ov_vendortree_getassociations()::        Get list of associations in the database.
* ov_vendortree_getclasses()::             Get list of classes in the database.
* ov_vendortree_getdatabasefrag()::        Get fragmentation of the database.
* ov_vendortree_getdatabasefree()::        Get free storage of the database.
* ov_vendortree_getdatabasename()::        Get database name.
* ov_vendortree_getdatabasesize()::        Get size of the database.
* ov_vendortree_getdatabasestarted()::     Get whether the database is started or not.
* ov_vendortree_getdatabaseused()::        Get used storage of the database.
* ov_vendortree_getname()::                Get vendor name.
* ov_vendortree_getlibksversion()::        Get LibKS version.
* ov_vendortree_getlibovversion()::        Get LibOV version.
* ov_vendortree_getlibovksversion()::      Get LibOVKS version.
* ov_vendortree_getlibraries()::           Get list of libraries in the database.
* ov_vendortree_getsemanticflags()::       Get list of semantic flags in the database.
* ov_vendortree_getserverdescription()::   Get server description.
* ov_vendortree_getservername()::          Get server name.
* ov_vendortree_getservertime()::          Get server time.
* ov_vendortree_getserverversion()::       Get server version.
* ov_vendortree_getstartuptime()::         Get startup time.
* ov_vendortree_getstructures()::          Get list of structures in the database.
@end menu

@c	--------------------------------

@node OV_FNC_GETVENDORVAR, OV_VENDORTREE_INFO, Vendortree, Vendortree
@section Function prototype for getting vendor variables

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{typedef OV_RESULT OV_FNC_GETVENDORVAR(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node OV_VENDORTREE_INFO, ov_vendortree_init(), OV_FNC_GETVENDORVAR, Vendortree
@section Information of a vendor tree object

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{typedef struct @{
    OV_STRING             identifier;
    OV_STRING             unit;
    OV_FNC_GETVENDORVAR   *getvarfnc;
@}   OV_VENDORTREE_INFO;}
@end format

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_init(), ov_vendortree_getunit(), OV_VENDORTREE_INFO, Vendortree
@section Initialize the vendor tree

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@code{void ov_vendortree_init(void);}

@strong{Parameters}

none

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getunit(), ov_vendortree_getvar(), ov_vendortree_init(), Vendortree
@section Get unit of a vendor object

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_STRING ov_vendortree_getunit(
    OV_INSTPTR_ov_object   pobj
);}
@end format

@strong{Parameters}

@table @code
@item pobj

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getvar(), ov_vendortree_setdatabasename(), ov_vendortree_getunit(), Vendortree
@section Get variable of a vendor object

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getvar(
    OV_INSTPTR_ov_object   pobj,
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pobj

@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_setdatabasename(), ov_vendortree_setname(), ov_vendortree_getvar(), Vendortree
@section Set database name

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_vendortree_setdatabasename(
    OV_STRING   name
);}
@end format

@strong{Parameters}

@table @code
@item name

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_setname(), ov_vendortree_setsemanticflag(), ov_vendortree_setdatabasename(), Vendortree
@section Set vendor name

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_vendortree_setname(
    OV_STRING   name
);}
@end format

@strong{Parameters}

@table @code
@item name

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_setsemanticflag(), ov_vendortree_setservername(), ov_vendortree_setname(), Vendortree
@section Set semantic flag

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_vendortree_setsemanticflag(
    OV_UINT     flagnum,
    OV_STRING   flagvalue
);}
@end format

@strong{Parameters}

@table @code
@item flagnum

@item flagvalue

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_setservername(), ov_vendortree_setserverdescription(), ov_vendortree_setsemanticflag(), Vendortree
@section Set server name

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_vendortree_setservername(
    OV_STRING   name
);}
@end format

@strong{Parameters}

@table @code
@item name

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_setserverdescription(), ov_vendortree_setserverversion(), ov_vendortree_setservername(), Vendortree
@section Set server description

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_vendortree_setserverdescription(
    OV_STRING   name
);}
@end format

@strong{Parameters}

@table @code
@item name

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_setserverversion(), ov_vendortree_setstartuptime(), ov_vendortree_setserverdescription(), Vendortree
@section Set server version

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_vendortree_setserverversion(
    OV_STRING   name
);}
@end format

@strong{Parameters}

@table @code
@item name

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_setstartuptime(), ov_vendortree_getassociations(), ov_vendortree_setserverversion(), Vendortree
@section Set startup time

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT void ov_vendortree_setstartuptime(
    OV_TIME   *ptime
);}
@end format

@strong{Parameters}

@table @code
@item ptime

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getassociations(), ov_vendortree_getclasses(), ov_vendortree_setstartuptime(), Vendortree
@section Get list of associations in the database

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getassociations(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getclasses(), ov_vendortree_getdatabasefrag(), ov_vendortree_getassociations(), Vendortree
@section Get list of classes in the database

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getclasses(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getdatabasefrag(), ov_vendortree_getdatabasefree(), ov_vendortree_getclasses(), Vendortree
@section Get fragmentation of the database

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getdatabasefrag(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getdatabasefree(), ov_vendortree_getdatabasename(), ov_vendortree_getdatabasefrag(), Vendortree
@section Get free storage of the database

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getdatabasefree(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getdatabasename(), ov_vendortree_getdatabasesize(), ov_vendortree_getdatabasefree(), Vendortree
@section Get database name

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getdatabasename(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getdatabasesize(), ov_vendortree_getdatabasestarted(), ov_vendortree_getdatabasename(), Vendortree
@section Get size of the database

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getdatabasesize(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getdatabasestarted(), ov_vendortree_getdatabaseused(), ov_vendortree_getdatabasesize(), Vendortree
@section Get whether the database is started or not

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getdatabasestarted(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getdatabaseused(), ov_vendortree_getname(), ov_vendortree_getdatabasestarted(), Vendortree
@section Get used storage of the database

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getdatabaseused(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getname(), ov_vendortree_getlibksversion(), ov_vendortree_getdatabaseused(), Vendortree
@section Get vendor name

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getname(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getlibksversion(), ov_vendortree_getlibovversion(), ov_vendortree_getname(), Vendortree
@section Get LibKS version

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getlibksversion(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getlibovversion(), ov_vendortree_getlibovksversion(), ov_vendortree_getlibksversion(), Vendortree
@section Get LibOV version

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getlibovversion(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getlibovksversion(), ov_vendortree_getlibraries(), ov_vendortree_getlibovversion(), Vendortree
@section Get LibOVKS version

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getlibovksversion(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getlibraries(), ov_vendortree_getsemanticflags(), ov_vendortree_getlibovksversion(), Vendortree
@section Get list of libraries in the database

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getlibraries(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getsemanticflags(), ov_vendortree_getserverdescription(), ov_vendortree_getlibraries(), Vendortree
@section Get list of semantic flags in the database

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getsemanticflags(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getserverdescription(), ov_vendortree_getservername(), ov_vendortree_getsemanticflags(), Vendortree
@section Get server description

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getserverdescription(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getservername(), ov_vendortree_getservertime(), ov_vendortree_getserverdescription(), Vendortree
@section Get server name

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getservername(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getservertime(), ov_vendortree_getserverversion(), ov_vendortree_getservername(), Vendortree
@section Get server time

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getservertime(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getserverversion(), ov_vendortree_getstartuptime(), ov_vendortree_getservertime(), Vendortree
@section Get server version

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getserverversion(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getstartuptime(), ov_vendortree_getstructures(), ov_vendortree_getserverversion(), Vendortree
@section Get startup time

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getstartuptime(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	--------------------------------

@node ov_vendortree_getstructures(), , ov_vendortree_getstartuptime(), Vendortree
@section Get list of structures in the database

@strong{Header file}

@code{#include "libov/ov_vendortree.h"}

@strong{Declaration}

@format
@t{OV_DLLFNCEXPORT OV_RESULT ov_vendortree_getstructures(
    OV_VAR_CURRENT_PROPS   *pvarcurrprops,
    const OV_TICKET        *pticket
);}
@end format

@strong{Parameters}

@table @code
@item pvarcurrprops

@item pticket

@end table

@strong{Return value}

@strong{Remarks}

@c	===============================
@c	Part 6: The End of the Document
@c	===============================

@contents
@bye

